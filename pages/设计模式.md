- [golang版本](https://github.com/senghoo/golang-design-pattern)  [c++](https://github.com/liu-jianhao/Cpp-Design-Patterns/blob/master/Singleton/Singleton.cpp)
  :LOGBOOK:
  CLOCK: [2022-03-15 Tue 17:37:22]
  CLOCK: [2022-03-15 Tue 17:37:32]
  :END:
- 创建型模式
  id:: 623056c4-d738-4ddc-b234-e6a1cf1c07c7
	- 简单工厂 [github-design-pattern 01.factory](https://github.com/feng1o/design-pattern/blob/master/01.simple_factory.cpp)
	- 工厂方法
	- 抽象工厂
	- 建造者
	- 单例模式
- 结构型模式
  id:: 6230572c-e129-453c-b946-62a9d5705ffd
	- <a class="gray subw  inline-box underline" 
	   href=https://blog.csdn.net/LU_ZHAO/article/details/105223637><span style="color: red;background-color: lightblue;font-weight:bold;font-size:12px">adapter decorator proxy区别:</span>适配器模式和装饰模式。两者都被称为包装模式，在功能上是较为接近的.  
	   2.类适配器比较直接直接继承待适配类，实现接口，对象适配器持有一个带适配的obj
	   3.与之相对，装饰者实现待装饰接口或继承待装饰类的同时持有一个 待装饰的实例, decorator更复杂
	   4. 结构上的不同在于从类图中可以看出，装饰模式持有和继承的一般是同一个类或接口，而适配器持有的是待适配的对象，实现的是目标接口
	   5. 功能上的不同在于装饰模式中装饰过的类力求与原来对外接口一致。这使得在调用方看来，装饰过后的类与之前没有什么区别，只是某一方面功能增强了。但是适配器模式中适配器则扩展了待适配类新的功能。简单来说，**装饰模式增强了原有功能，适配器模式拓展了新的功能。**我们也可以看出，装饰模式与适配器模式是不冲突的，可以既增强原有功能，又添加全新的功能
	  
	  装饰模式VS代理模式
	  代理模式中，代理方对被代理方有控制权，对于调用方来说两者是分工十分清楚的两个类，调用者很清楚它调用的是代理方。代理方的构造函数可以有多个参数，这使得它可以根据外界环境决定被代理方的运行与否。装饰模式中，装饰者这是增强了被装饰者的某种功能，对于调用方来说两者几乎没有区别
	  
	  总结  代理持有一个对象，根据外界环境决定代理的行为，出于某种原因（远程，安全）不直接去调用对象。适配器是相对固定的转换成某种指定的功能，由于接口不兼容。装饰模式主要用于添加新的功能，缺点是类的结构变复杂且不易区分。</a>
	-
	- [[适配器]] <a href=https://blog.csdn.net/lh844386434/article/details/17928331>插头适配器understand</a>
	- [[装饰器]] 包装模式
	- [[桥接]]
	- 外观模式
	- 代理模式
- 行为型模式
  id:: 62305808-87c4-4f79-88e5-1619f55b53b3
	- 命令模式
	- 中介模式
	- 观察者模式
	- 状态模式
	- 策略模式
-