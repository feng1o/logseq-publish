- [[用户级/线程模型]]
	- 用户层面多线程，和内核线程N-1关系，内核只知道用户进程，用户层的线程自己调度控制。
	- 原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如 I/O 阻塞）而被 CPU 给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有 CPU 时钟中断的，从而没有轮转调度），整个进程被挂起
	- 解决：`协程库`会把自己一些阻塞的操作重新封装为完全的**非阻塞形式**，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该 KSE 上运行，从而避免了内核调度器由于 KSE 阻塞而做上下文切换，这样整个进程也不会被阻塞了
- [[内核级线程模型]]
	- 线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成
- [[混合线程模型/两级线程模型]]
	- 用户线程与内核 KSE 是多对多（N : M）的映射模型
	- <a><strong>即用户调度器实现用户线程到 KSE 的『调度』，内核调度器实现 KSE 到 CPU 上的『调度』</strong></a>
	-