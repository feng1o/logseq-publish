file-path:: ../assets/ANTLR_4权威指南_1668407377609_0.pdf

- file-path:: ../assets/ANTLR_4权威指南_1668407377609_0.pdf
  file:: [ANTLR_4权威指南_1668407377609_0.pdf](../assets/ANTLR_4权威指南_1668407377609_0.pdf)
  title:: hls__ANTLR_4权威指南_1668407377609_0
- [对应代码-github](https://github.com/GaoGian/ANTLR-4-Resource-Code/tree/master/code)
- #### 第2章 纵观全局
  ls-type:: annotation
  hl-page:: 26
  id:: 6371e1a2-0688-4d76-a96d-4c3d1ed99336
  background-color:: #978626
  heading:: true
	- 学习语言类应用程序相关的重要过程、术语和数据结构
	  ls-type:: annotation
	  hl-page:: 26
	  id:: 6371e1ba-cf0d-4d0f-99bf-b1cabbdbcdb3
	- ##### 2.1 从ANTLR元语言开始
	  hl-page:: 27
	  ls-type:: annotation
	  id:: 6371e1c6-c8af-4be6-a16f-f863f52c6c70
	  background-color:: #49767b
	  collapsed:: true
		- 语言（language）由一系列有意义的语句组成，语句（sentence）由词组组成，词组（phrase）是由更小的子词组（subphrase）和词汇符号（vocabulary symbol）组成
		  hl-page:: 27
		  ls-type:: annotation
		  id:: 6371e1fa-f8c0-4026-a29e-583df6b1b3e1
		- 一个程序能够分析计算或者“执行”语句，我们就称之为[[解释器]]（interpreter）
		  ls-type:: annotation
		  hl-page:: 27
		  id:: 6371e211-4f92-4934-a533-39a6677bb2cf
		- 程序能够将一门语言的语句转换为另外一门语言的语句，我们称之为[[翻译器]]（translator）
		  ls-type:: annotation
		  hl-page:: 27
		  id:: 6371e227-065f-46da-b70b-eb7c5fecc879
		- 识别语言的程序称为[[语法分析器]]（parser）或者[[句法分析器]]（syntaxanalyzer）
		  hl-page:: 27
		  ls-type:: annotation
		  id:: 6371e260-02c7-4832-b0d4-074e4981fe66
		- 语法（grammar）是一系列规则的集合; 每条规则表述出一种词汇结构
		  hl-page:: 27
		  ls-type:: annotation
		  id:: 6371e28f-beb0-47bb-b981-33a15996e4aa
		- ANTLR语法本身又遵循了一种专门用来描述其他语言的语法，我们称之为[[ANTLR元语言]]
		  ls-type:: annotation
		  hl-page:: 28
		  id:: 6371e324-dfa8-4fc6-a30e-24d78db20e81
		- 字符聚集为单词或者符号（词法符号，token）的过程称为[[词法分析]]（lexicalanalysis）或者[[词法符号化]]（tokenizing）。
		  hl-page:: 28
		  ls-type:: annotation
		  id:: 6371e35d-3b04-4138-a2d1-29fbdb37f213
		- ANTLR生成的语法分析器会建造一种名为语法分析树（parse tree）或者句法树（syntax tree）的数据结构，该数据结构记录了语法分析器识别出输入语句结构的过程
		  hl-page:: 28
		  ls-type:: annotation
		  id:: 6371e3b6-7f84-4b8d-ad9d-5926fc2f0048
		- ((63e7487d-1e76-4e4a-869d-21232e3c52b5))
		- 语法分析树的内部节点是词组名
		  ls-type:: annotation
		  hl-page:: 29
		  id:: 6371e3fc-4d4a-46ba-8e5d-b63c79e153c4
		- 语法分析树的叶子节点永远是输入的词法符号
		  hl-page:: 29
		  ls-type:: annotation
		  id:: 6371e412-af14-4166-8a52-04e2dc16aa9c
	- ##### 2.2 实现一个语法分析器
	  hl-page:: 30
	  ls-type:: annotation
	  id:: 6371e475-3b5a-431c-9415-ff2e8adaaca2
	  background-color:: #49767b
	  collapsed:: true
		- 递归下降的语法分析器（recursive-descent parser）。
		  ls-type:: annotation
		  hl-page:: 30
		  id:: 6371e51e-59ee-4637-9fed-52fba0142ae2
		- “自上而下的解析”，递归下降的语法分析器仅仅是自上而下的语法分析器的一种实现
		  ls-type:: annotation
		  hl-page:: 30
		  id:: 6371e53e-d20b-42ba-abe1-e200179080ba
		- [:span]
		  ls-type:: annotation
		  hl-page:: 31
		  id:: 6371e64a-eafc-4059-a8bf-d4dde3c7b478
		  hl-type:: area
		  hl-stamp:: 1668408904552
		- stat（）方法必须通过检查下一个词法符号来做出语法分析决策（parsingdecision）或者预测（prediction）。
		  ls-type:: annotation
		  hl-page:: 32
		  id:: 6371e65e-7bf8-4bfd-a03b-e2e60fdea5d8
		- 有些时候，语法分析器需要很多个前瞻词法符号来判断语义规则的哪个方案是正确的，甚至可能要从当前的词法符号的位置开始，一直分析到文件末尾才能做出判断
		  ls-type:: annotation
		  hl-page:: 32
		  id:: 6371e698-bf9c-40c0-9085-9b00732e3a70
		- 在上例中的stat规则中，每个备选分支都是以一个独一无二的词法符号开始的，因此stat（）方法可以通过检查第一个前瞻词法符号来区分不同的备选分支
		  ls-type:: annotation
		  hl-page:: 32
		  id:: 6371e762-0a48-44fc-8102-737ea78b25f2
	- <span> <a class=ask>  前瞻词- 都在stat中吗？ 那stat中决定了支持走哪些分之来生成语句 </a>  <span class=" bg-green white  subw hblack hover"> [[2022-11-14 Mon]] </span></span>
	- ##### 2.3 歧义性语句
	  hl-page:: 33
	  ls-type:: annotation
	  id:: 6371e7f5-ebe3-4e02-80ae-8548a972218a
	  background-color:: #49767b
	  collapsed:: true
		- 大多数情况下，歧义的表现更为微妙。在下面的语法中，stat规则包含两个备选分支，二者都可以匹配一个函数调用语句
		  ls-type:: annotation
		  hl-page:: 34
		  id:: 6371ea84-be9e-4e57-8c0e-b1eea43416ea
		- ANTLR解决歧义问题的方法是：选择所有匹配的备选分支中的第一条
		  ls-type:: annotation
		  hl-page:: 35
		  id:: 6371eb3b-03d8-4976-87f8-4b99e5a1074a
		- 词法分析器会匹配可能的最长字符串来生成一个词法符号
		  ls-type:: annotation
		  hl-page:: 36
		  id:: 6371eb6f-cf4c-4147-b11f-34a07d7fc494
		- 2.4 使用语法分析树来构建语言类应用程序
		  ls-type:: annotation
		  hl-page:: 36
		  id:: 6371eb88-5b5a-4ddb-af5e-dd0df41a7898
		- ParseTree的子类RuleNode和TerminalNode，二者分别是子树的根节点和叶子节点
		  ls-type:: annotation
		  hl-page:: 37
		  id:: 6371ee37-2b0e-442d-baa1-d37ab378ebe2
		- 例如，AssignContext类提供了方法ID（）和方法expr（）来访问标识符节点和代表表达式的子树
		  ls-type:: annotation
		  hl-page:: 39
		  id:: 6371ee4d-fefc-4399-b8b7-6246761b2234
	- ##### 2.5 语法分析树监听器和访问器
	  hl-page:: 39
	  ls-type:: annotation
	  id:: 6371ee7e-7bf3-4e27-9e3c-aca0bdd640a4
	  background-color:: #49767b
	  collapsed:: true
		- ANTLR的运行库提供了两种遍历树的机制
		  ls-type:: annotation
		  hl-page:: 39
		  id:: 6371eeaf-dd34-4c82-87ba-2f3935fd05b6
		- 1.语法分析树监听器
		  ls-type:: annotation
		  hl-page:: 40
		  id:: 6371eec3-c6ec-4013-88f2-98a22ddf32a5
		- 我们可以自行实现ParseTreeListener接口，在其中填充自己的逻辑代码（通常是调用程序的其他部分），从而构建出我们自己的语言类应用程序
		  ls-type:: annotation
		  hl-page:: 40
		  id:: 6371eede-9ca5-4d70-b2b5-3e44e2f56f2d
		- 2-4用粗虚线标识了ParseTreeWalker对语法分析树进行深度优先遍历的过程
		  ls-type:: annotation
		  hl-page:: 40
		  id:: 6371eefc-e34f-4a94-be72-6d15ab08e2dd
		- 2.语法分析树访问器
		  ls-type:: annotation
		  hl-page:: 42
		  id:: 6371ef29-3dbd-4c54-b64f-e527ec5c383a
		- 可以在自己的程序代码中实现这个访问器接口，然后调用visit（）方法来开始对语法分析树的一次遍历
		  ls-type:: annotation
		  hl-page:: 43
		  id:: 6371ef62-43bc-4f6a-b143-8a5c8e53231c
	- ##### 本章介绍了很多重要的与语言识别相关的术语。
	  hl-page:: 44
	  ls-type:: annotation
	  id:: 6371ef7c-3652-4fb0-8bd3-1eab2800f5ce
	  background-color:: #49767b
	  collapsed:: true
		- 语言 一门语言是一个有效语句的集合。语句由词组组成，词组由子词组组成，子词组又由更小的子词组组成
		  ls-type:: annotation
		  hl-page:: 44
		  id:: 6371efa2-3f60-4f34-bc0b-acb05f3dc5fb
		- 语法 语法定义了语言的语义规则
		  ls-type:: annotation
		  hl-page:: 44
		  id:: 6371efa9-336a-45e6-ae3c-f38897ef162c
		- 词法符号 词法符号就是一门语言的基本词汇符号
		  ls-type:: annotation
		  hl-page:: 44
		  id:: 6371efb4-190c-4061-9a9e-12bab91adf2b
		- 语法分析器 语法分析器通过检查语句的结构是否符合语法规则的定义来验证该语句在特定语言中是否合法
		  ls-type:: annotation
		  hl-page:: 44
		  id:: 6371efbf-afca-40f3-a70c-d94aa7f8140d
- #### 第3章 入门的ANTLR项目
  ls-type:: annotation
  hl-page:: 45
  id:: 6371efd1-a4a1-4032-b3ef-ad72ae46c4d9
  background-color:: #978626
	- 数组构建  学到如下内容：一些ANTLR语法的语义元素定义、ANTLR根据语法自动生成代码的机制、如何将自动生成的语法分析器和Java程序集成，以及如何使用语法分析树监听器编写一个代码翻译工具
	  hl-page:: 46
	  ls-type:: annotation
	  id:: 6371f03e-ccba-44d8-b73f-ce53bb28c02f
	- 3.1 ANTLR工具、运行库以及自动生成的代码
	  ls-type:: annotation
	  hl-page:: 46
	  id:: 6371f05f-fc3c-44c0-b748-14d214331254
		- [:span]
		  ls-type:: annotation
		  hl-page:: 47
		  id:: 6371f0e8-d92b-47e2-acf8-797f241ceb17
		  hl-type:: area
		  hl-stamp:: 1668411623636
		- ArrayInitParser.java：该文件包含一个语法分析器类的定义，这个语法分析器专门用来识别我们的“数组语言”的语法ArrayInit
		  ls-type:: annotation
		  hl-page:: 48
		  id:: 6371f14b-85a4-4e17-b874-e66f6f9d03ec
		- ArrayInitLexer.java：ANTLR能够自动识别出我们的语法中的文法规则和词法规则
		  ls-type:: annotation
		  hl-page:: 48
		  id:: 6371f159-2252-4969-a3b2-46e71a8c6f7e
		- ArrayInit.tokens：ANTLR会给每个我们定义的词法符号指定一个数字形式的类型，然后将它们的对应关系存储于该文件中
		  ls-type:: annotation
		  hl-page:: 48
		  id:: 6371f16c-a028-4523-a406-8cca86669c10
		- ArrayInitListener.java，ArrayInitBaseListener.java：默认情况下，ANTLR生成的语法分析器能将输入文本转换为一棵语法分析树
		  ls-type:: annotation
		  hl-page:: 48
		  id:: 6371f18f-df93-4c2a-ba3b-c3b17a199def
	- 3.2 测试生成的语法分析器
	  ls-type:: annotation
	  hl-page:: 49
	  id:: 6371f1e2-f73f-42c5-9939-75400bd818b9
	- 3.3 将生成的语法分析器与Java程序集成
	  ls-type:: annotation
	  hl-page:: 53
	  id:: 6371f255-c481-4ad2-85da-6a0dcc12f2f9
	- 3.4 构建一个语言类应用程序
	  ls-type:: annotation
	  hl-page:: 55
	  id:: 6371f285-0277-480e-bd19-75d136b7147c
		- 监听器机制的优雅之处在于，我们不需要自己编写任何遍历语法分析树的代码
		  ls-type:: annotation
		  hl-page:: 56
		  id:: 6371f2be-b2a1-4a09-9516-3f851e3b7f3d
		- 用自然语言解释，翻译过程就是一系列“X映射为Y”的过程： {99, 3, 451}  ----翻译为string bytes
		  hl-page:: 56
		  ls-type:: annotation
		  id:: 6371f2eb-a391-45bc-8024-10e9dd2d7169
		- 1) 将{翻译为"。2）将}翻译为"。3）将每个整数翻译为四位的十六进制形式，然后加前缀\u
		  hl-page:: 56
		  ls-type:: annotation
		  id:: 6371f301-f6f5-45ec-b187-f62996c8a4cb
- #### 第4章 快速指南
  ls-type:: annotation
  hl-page:: 59
  id:: 6371f368-c360-436e-b39a-e9d0bbe54162
  background-color:: #978626
	- 本章中，我们将会通过几个功能强大的示例程序来快速上手ANTLR
	  ls-type:: annotation
	  hl-page:: 59
	  id:: 6371f380-d737-47ef-b64f-56227f8b8a2f
	- 大多数情况下，我们都是通过访问器和监听器来构建语言类应用程序的，但是为了实现极端的灵活性，ANTLR允许直接将自定义的程序代码嵌入生成的语法分析器
	  ls-type:: annotation
	  hl-page:: 60
	  id:: 6371f3c7-fe80-46c1-a7bf-fc235e7ba232
	- ##### 4.1 匹配算术表达式的语言
	  hl-page:: 61
	  ls-type:: annotation
	  id:: 6371f4ae-89de-41ea-9bfb-bebd96d0cb79
	  background-color:: #49767b
	  collapsed:: true
		- [code.g4](https://github.com/GaoGian/ANTLR-4-Resource-Code/blob/master/code/tour/Expr.g4)
		  background-color:: darkred
		- 语法包含一系列描述语言结构的规则。这些规则既包括类似stat和expr的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号（词法符号）的规则
		  ls-type:: annotation
		  hl-page:: 62
		  id:: 6371f5e6-585b-412d-9dc1-2e355127c275
		- ·语法分析器的规则以小写字母开头
		  ls-type:: annotation
		  hl-page:: 62
		  id:: 6371f5f8-3317-45ef-a323-f42386dcda4b
		- ·词法分析器的规则以大写字母开头
		  ls-type:: annotation
		  hl-page:: 62
		  id:: 6371f5fc-a973-40b4-9cfc-88e55fd6dd68
		- 使用|来分隔同一个语言规则的若干备选分支
		  ls-type:: annotation
		  hl-page:: 62
		  id:: 6371f601-d5f0-4672-b134-b765473d9228
		- hl-page:: 66
		  ls-type:: annotation
		  id:: 6371f6b9-a8d9-4aa6-9a32-82b8510984f7
		  1.语法导入::  拆分并import
		- 2.处理有错误的输入
		  ls-type:: annotation
		  hl-page:: 67
		  id:: 6371f727-d9e5-46c6-8577-819d73145d5e
	- 4.2 利用访问器构建一个计算器
	  ls-type:: annotation
	  hl-page:: 70
	  id:: 6371f75d-718f-4d01-86fd-3a7f39033953
	  collapsed:: true
		- 推荐使用语法分析树访问器和其他的遍历器来实现语言类应用程序，从而保持语法本身的整洁
		  ls-type:: annotation
		  hl-page:: 70
		  id:: 6371f77d-d1f0-4a59-8e93-ca94dd5aace2
		- 需要先==对语法做少量的修改==。首先，我们需要给备选分支==加上标签==（这些标签可以是任意标识符，只要它们不与规则名冲突）。如果备选分支上面没有标签，ANTLR就只为每条规则生成一个方法
		  hl-page:: 70
		  ls-type:: annotation
		  id:: 6371f79d-06d5-45f7-a384-df402d458277
		- [:span]
		  ls-type:: annotation
		  hl-page:: 70
		  id:: 6371f7ea-78a5-4260-a70c-ab1f8028d52e
		  hl-type:: area
		  hl-stamp:: 1668413417673
		- [visitor.实现](https://github.com/GaoGian/ANTLR-4-Resource-Code/blob/master/code/tour/EvalVisitor.java)
	- 4.3 利用监听器构建一个翻译程序  (这个例子：未see，需看 )
	  hl-page:: 75
	  ls-type:: annotation
	  id:: 6371f934-a07a-483d-a3eb-e693e99ee990
	  collapsed:: true
		- 让你编写一个工具，用来将一个Java类中的全部方法抽取出来，生成一个接口文件
		  ls-type:: annotation
		  hl-page:: 75
		  id:: 6371f949-fba8-4bb1-8291-b1aac92b95dc
		- hl-page:: 76
		  ls-type:: annotation
		  id:: 6371f9d3-c63e-4621-aa38-f1725b06c57d
		  ==访问器机制和监听器机制的最大的区别==:: 监听器的方法会被ANTLR提供的遍历器对象自动调用，而在访问器的方法中，必须显式调用visit方法来访问子节点。忘记调用visit（）的后果就是对应的子树将不会被访问
	- 4.4 定制语法分析过程
	  ls-type:: annotation
	  hl-page:: 80
	  id:: 6371fac9-6841-4c30-ab96-3736ffc7ba76
	  collapsed:: true
		- 为了极佳的灵活性和可操控性，我们可以直接将代码片段（动作）嵌入语法中
		  ls-type:: annotation
		  hl-page:: 80
		  id:: 6371fb18-7857-4ef3-a159-d7ccc5624455
		- 1.在语法中嵌入任意动作
		  ls-type:: annotation
		  hl-page:: 80
		  id:: 6371fb29-4b0b-4341-a959-ca98a626f26a
		- 我们来构建一个能够打印若干行数据中的指定列的程序
		  ls-type:: annotation
		  hl-page:: 80
		  id:: 6371fb6d-7e3d-4da5-be92-a4581d6a9cba
		- 2.使用语义判定改变语法分析过程
		  ls-type:: annotation
		  hl-page:: 82
		  id:: 6371fbff-4694-4cbb-a6ac-5fb36c1b2336
	- 4.5 神奇的词法分析特性
	  ls-type:: annotation
	  hl-page:: 85
	  id:: 6371fd15-bbf5-4fe4-ac9e-65c6456d605b
	- ---- too see ----
	-
- ###第二部分 ANTLR开发语言类应用程序
  ls-type:: annotation
  hl-page:: 91
  id:: 6371fd55-28c0-4443-8424-a7bbe8395bb1
- #### 第5章 设计语法
  ls-type:: annotation
  hl-page:: 92
  id:: 6371fd69-20bb-4411-82b8-0b3ce64cf24b
  background-color:: #978626
	- 例如建立内部数据结构，提取信息，以及翻译输入内容等
	  ls-type:: annotation
	  hl-page:: 92
	  id:: 6371fd77-4b38-4638-bc52-764b040aa3eb
	- 不能仅仅通过一些晦涩难懂的ANTLR概念来学习构造语法。首先，我们需要研究编程语言的通用模式
	  ls-type:: annotation
	  hl-page:: 92
	  id:: 6371fd89-9392-4029-85c5-64d010e0b23a
	- 语言的结构（一种语言模式就是一种递归的语法结构，例如，英语的一个句子包含“主语-谓语动词-宾语”，而日语的一个句子包含“主语-宾语-谓语动词”）
	  ls-type:: annotation
	  hl-page:: 92
	  id:: 6371fd9b-2b79-4105-9179-241e858f6958
	- 巴克斯-诺尔范式，Backus-Naur-Format， [[BNF范式]]
	  ls-type:: annotation
	  hl-page:: 93
	  id:: 6371fdce-ee91-40c1-aa67-f7f81fb960bd
	- 5.1 从编程语言的范例代码中提取语法
	  ls-type:: annotation
	  hl-page:: 93
	  id:: 6371fdec-a5c8-4f3c-8f4a-1b576f41838c
		- 记住，ANTLR将会为你的语法中的每条规则生成一个函数
		  ls-type:: annotation
		  hl-page:: 93
		  id:: 6371fe1e-f0cc-48e2-b86e-0e2937a38f3b
		- 深入研究语法的细节之前，一件大有裨益的事情是：==讨论语法的整体结构以及如何建立初始的语法框架==
		  hl-page:: 93
		  ls-type:: annotation
		  id:: 6371fe2f-4a3e-44c4-94c5-fff93b1e043c
		- hl-page:: 94
		  ls-type:: annotation
		  id:: 6371fe5e-9312-4a34-9be2-0d57583c2294
		  ==语法==::  由一个为该语法命名的头部定义和一系列可以相互引用的语言规则组成
		- [:span]
		  ls-type:: annotation
		  hl-page:: 94
		  id:: 6371fe68-db42-4e31-a02e-e453bd95ad9b
		  hl-type:: area
		  hl-stamp:: 1668415079349
	- 5.2 以现有的语法规范为指南
	  ls-type:: annotation
	  hl-page:: 96
	  id:: 6371ff25-6822-4226-9c4d-1f48f57a23d5
	- 5.3 使用ANTLR语法识别常见的语言模式
	  ls-type:: annotation
	  hl-page:: 97
	  id:: 6371ff5d-fd7a-4235-bc3a-99df1d5e696c
		- 接下来我们需要关注的是常见的语言模式：序列（sequence）、选择（choice）、词法符号依赖（token dependency），以及嵌套结构（nested phrase）
		  ls-type:: annotation
		  hl-page:: 98
		  id:: 6371ff80-d6f9-4202-a43b-0b1fc9273e28
		- 1.序列模式
		  ls-type:: annotation
		  hl-page:: 98
		  id:: 6371ff86-fdb7-4bdb-8298-eb91500b5440
			- 多数指令由一个类似USER和==RETR==的关键字（保留字）
			  ls-type:: annotation
			  hl-page:: 98
			  id:: 6371ffe3-d2be-4d56-93de-f26e1470c4b0
			- [:span]
			  ls-type:: annotation
			  hl-page:: 98
			  id:: 6371fff9-d192-4ee1-99d0-57cb1a7f0663
			  hl-type:: area
			  hl-stamp:: 1668415480494
		- 2.选择模式（多个备选分支）  |
		  ls-type:: annotation
		  hl-page:: 100
		  id:: 637200a5-04dd-4549-ad60-eca7c898aef9
		- 3.词法符号依赖模式
		  ls-type:: annotation
		  hl-page:: 101
		  id:: 637200e3-b911-4c9a-984a-ee98598f48da
		- [:span]
		  ls-type:: annotation
		  hl-page:: 102
		  id:: 637201c8-15a0-4c88-83b1-2879eaf1f5aa
		  hl-type:: area
		  hl-stamp:: 1668415943130
		- 4.嵌套模式  while
		  ls-type:: annotation
		  hl-page:: 103
		  id:: 63720214-d6fc-4cef-ac43-11606861518a
			- [:span]
			  hl-type:: area
			  hl-stamp:: 1668416066190
			  hl-page:: 104
			  ls-type:: annotation
			  id:: 63720243-68ce-4c46-a6ed-3132ca4e3c77
		- 大部分编程语言都包含多种形式的自相似结构，这带来的结果是语法中包含很多递归规则
		  ls-type:: annotation
		  hl-page:: 104
		  id:: 63720270-fcb7-4f3d-9c71-3c170e5c00a1
		- 一起来看一门简单的、表达式类型只有三种——数组索引表达式、括号表达式和整数——的编程语言
		  ls-type:: annotation
		  hl-page:: 104
		  id:: 6372027b-a31c-49e6-887c-f576f174f03a
		- ==语法分析树的非叶子节点代表了规则，而叶子节点代表了词法符号==
		  ls-type:: annotation
		  hl-page:: 105
		  id:: 637202ab-1ce0-4138-8804-132815bdc77b
	- 5.4 处理优先级、左递归和结合性
	  ls-type:: annotation
	  hl-page:: 107
	  id:: 63720366-c5ec-4f05-a59a-dd774d8eab46
		- 运算符优先级带来的问题，传统的语法无法指定优先级。大多数语法工具，例如Bison，使用额外的标记来指定运算符优先级
		  ls-type:: annotation
		  hl-page:: 109
		  id:: 637203ad-c2f6-40f7-b9a4-8ec1d07c3c0c
		- 与之不同的是，ANTLR通过优先选择位置靠前的备选分支来解决歧义问题
		  ls-type:: annotation
		  hl-page:: 109
		  id:: 637203b9-d5e7-48f9-9f3e-bc262b157282
		- 使用assoc选项手工指定结合性
		  ls-type:: annotation
		  hl-page:: 109
		  id:: 637203e2-0128-41c8-8aee-7ce829e602f6
	- 5.5 识别常见的词法结构
	  ls-type:: annotation
	  hl-page:: 112
	  id:: 63720452-bda7-4eb4-adb8-c4c80c8b50f3
		- 由于词法分析和语法分析是语言识别过程中的两个不同阶段，我们必须告诉ANTLR每条规则对应的阶段
		  ls-type:: annotation
		  hl-page:: 113
		  id:: 63720487-21a7-4e74-a9c7-fbe03bfb6a6f
		- 为了展示词法规则，让我们一起来构造一些描述常见词法符号的词法规则的简化版本
		  ls-type:: annotation
		  hl-page:: 114
		  id:: 637204bd-b84c-4616-aaf3-20a14cac5bb5
	- 1.匹配标识符
	  ls-type:: annotation
	  hl-page:: 114
	  id:: 637204ca-3560-45d3-8331-e6f450bed26d
		- 'enum'这样的字符串常量被隐式定义为词法规则，然后放置在文法规则之后、显式定义的词法规则之前。ANTLR词法分析器解决歧义问题的方法是优先使用位置靠前的词法规则。这意味着，ID规则必须定义在所有的关键字规则之后
		  ls-type:: annotation
		  hl-page:: 115
		  id:: 63720550-8f76-46f3-bbec-e5c6f68edacd
		- 2.匹配数字
		  ls-type:: annotation
		  hl-page:: 116
		  id:: 63720583-e336-4435-b21f-7c0d22920e5b
		- 3.匹配字符串常量
		  ls-type:: annotation
		  hl-page:: 116
		  id:: 637205ae-0c19-48c8-a1cd-60044b490ad9
		- STRING规则还不够完善，因为它不允许其中出现双引号
		  ls-type:: annotation
		  hl-page:: 117
		  id:: 63720611-28d9-4627-a824-95af59206ba1
		- 4.匹配注释和空白字符
		  ls-type:: annotation
		  hl-page:: 118
		  id:: 63720638-63e1-4cac-8ad7-c2cc94da4176
		- [:span]
		  ls-type:: annotation
		  hl-page:: 118
		  id:: 6372065a-8b6a-4020-923c-cbd2cb82a777
		  hl-type:: area
		  hl-stamp:: 1668417113362
		- [:span]
		  ls-type:: annotation
		  hl-page:: 118
		  id:: 63720677-be2d-4bd9-821a-ad9063543140
		  hl-type:: area
		  hl-stamp:: 1668417142227
	- 5.6 划定词法分析器和语法分析器的界线
	  ls-type:: annotation
	  hl-page:: 121
	  id:: 637206c6-41d8-48d5-9ef7-b63c4615d652
	-
- #### 第6章 探索真实的语法世界
  hl-page:: 125
  ls-type:: annotation
  id:: 637206f0-950a-4ccd-982c-c55cd5ebb9e3
  background-color:: #978626
	- 目标是学习如何通过详细阅读参考手册、样例代码和已有的非ANTLR语法来构造完整的语法
	  ls-type:: annotation
	  hl-page:: 125
	  id:: 63720722-9360-4945-84a8-a4dc9e5ce30f
	- CSV是一个很好的起点，因为它简单而又被广泛使用。第二种语言也是一种数据格式，称为JSON，它包含嵌套的数据元素，从而能够让我们通过一门真正的语言来探索递归规则的应用
	  ls-type:: annotation
	  hl-page:: 125
	  id:: 63720738-89db-4fd6-8740-b9ddee6f5d4c
	- 6.1 解析CSV文件
	  ls-type:: annotation
	  hl-page:: 126
	  id:: 6372074e-cc7c-4f43-92e6-fc93baab4b9c
		- [:span] ---::  string这里包含双引号：
		  hl-type:: area
		  hl-stamp:: 1668417480538
		  hl-page:: 127
		  ls-type:: annotation
		  id:: 637207c9-2fe6-4d61-953f-f067473a02f8
			- ```antlr
			  grammar CSV;
			  	
			  	file : hdr row+ ;
			  	hdr : row ;
			  	
			  	row : field (',' field)* '\r'? '\n' ;
			  	
			  	field
			  	    :   TEXT
			  	    |   STRING
			  	    |
			  	    ;
			  	
			  	TEXT : ~[,\n\r"]+ ;
			  	STRING : '"' ('""'|~'"')* '"' ; // quote-quote is an escaped quote
			  ```
		- 这就是STRING规则的子规则（'""'|~'"'）*存在的原因。我们不能使用通配符来构造非贪婪循环（'""'|.）*？，因为它一旦遇到在字符串开始之后的第一个"，便会终止匹配过程。类似"x""y"的输入就会被匹配成两个字符串，而非单个包含""的字符串。要记住，非贪婪的子规则是在保证整个父规则匹配成功的前提下，匹配数量尽可能少的字符
		  ls-type:: annotation
		  hl-page:: 128
		  id:: 637207d7-247b-420d-99c2-b220a9e2bd1a
		- 6.2 解析JSON
		  ls-type:: annotation
		  hl-page:: 129
		  id:: 63720888-348f-4cac-93b9-3b2760510812
			- ```
			  	grammar JSON;
			  	
			  	json:   object
			  	    |   array
			  	    ;
			  	
			  	object
			  	    :   '{' pair (',' pair)* '}'
			  	    |   '{' '}' // empty object
			  	    ;
			  	pair:   STRING ':' value ;
			  	
			  	array
			  	    :   '[' value (',' value)* ']'
			  	    |   '[' ']' // empty array
			  	    ;
			  	
			  	value
			  	    :   STRING
			  	    |   NUMBER
			  	    |   object  // recursion
			  	    |   array   // recursion
			  	    |   'true'  // keywords
			  	    |   'false'
			  	    |   'null'
			  	    ;
			  	
			  	STRING :  '"' (ESC | ~["\\])* '"' ;
			  	
			  	fragment ESC :   '\\' (["\\/bfnrt] | UNICODE) ;
			  	fragment UNICODE : 'u' HEX HEX HEX HEX ;
			  	fragment HEX : [0-9a-fA-F] ;
			  	
			  	NUMBER
			  	    :   '-'? INT '.' [0-9]+ EXP? // 1.35, 1.35E-9, 0.3, -4.5
			  	    |   '-'? INT EXP             // 1e10 -3e4
			  	    |   '-'? INT                 // -3, 45
			  	    ;
			  	fragment INT :   '0' | [1-9] [0-9]* ; // no leading zeros
			  	fragment EXP :   [Ee] [+\-]? INT ; // \- since - means "range" inside [...]
			  	
			  	WS  :   [ \t\n\r]+ -> skip ;
			  ```
		- 2.JSON词法规则
		  ls-type:: annotation
		  hl-page:: 134
		  id:: 6372098b-815e-4023-8887-fa066a5df4bc
	- 6.3 解析DOT语言
	  ls-type:: annotation
	  hl-page:: 138
	  id:: 637209ad-e999-4245-b258-e85b88e4e7c5
	- 6.4 解析Cymbol语言
	  ls-type:: annotation
	  hl-page:: 146
	  id:: 63720a19-b361-4a06-ade0-0adc98fb5119
	- 6.5 解析R语言     -----   stoped , to see
	  hl-page:: 151
	  ls-type:: annotation
	  id:: 63720be4-a5ad-41df-be6a-7b75b2f3e23e
	  background-color:: darkturquoise
	-
- #### 第7章 将语法和程序的逻辑代码解耦
  hl-page:: 160
  ls-type:: annotation
  background-color:: #978626
  id:: 63720c76-afcc-4c07-b395-d941788c327a
- 通常单独的语法并没有用处，而与其相关的语法分析器才能告诉我们输入语句是否遵循该语言的规范
  ls-type:: annotation
  hl-page:: 160
  id:: 63720cd0-c131-4903-944b-62dc42c9452a
- 语法分析器需要在遇到特定的输入语句、词组或者词法符号时触发特定的行为。这样的词组→行为的集合构成了我们的语言类应用程序
  ls-type:: annotation
  hl-page:: 160
  id:: 63720ce2-d625-49ef-a31a-9878dc609356
- 学习如何使用语法分析树监听器和访问器来构建语言类应用程序
  ls-type:: annotation
  hl-page:: 160
  id:: 63720cf6-aa62-47fe-ba85-c3205179e7b5
- hl-page:: 161
  ls-type:: annotation
  id:: 63720d22-31d2-4b00-ad17-98c5f8abd610
  监听器和访问器机制的最大区别:: 监听器方法不负责显式调用子节点的访问方法，而访问器必须显式触发对子节点的访问以便树的遍历过程能够正常进行（正如我们在2.5节中看到的那样）。因为访问器机制需要显式调用方法来访问子节点，所以它能够控制遍历过程中的访问顺序，以及节点被访问的次数
- 首先了解监听器机制的起源，以及如何使用监听器和访问器机制来使得程序逻辑代码与语法分离
  ls-type:: annotation
  hl-page:: 161
  id:: 63720d46-ff57-492d-85bb-1819aca89400
- 7.1 从内嵌动作到监听器的演进
  ls-type:: annotation
  hl-page:: 161
  id:: 63720d5d-419c-4f94-9d3d-76ed910ffd4c
- 7.2 使用语法分析树监听器编写程序    
  hl-page:: 164
  ls-type:: annotation
  id:: 63720ec4-ab78-46d2-b044-23645093868c
	- ---  to see
- 7.3 使用访问器编写程序
  ls-type:: annotation
  hl-page:: 168
  id:: 6372113e-686b-42cc-a08d-5f51bc2f4c69
- 我们需要谨记在心的是，语法及其对应的语法分析树，以及访问器或者监听器事件方法之间的关系。除此之外，剩下的仅仅是普通的代码。在对输入文本进行识别时，我们可以产生输出、收集信息（正如本例中我们所做的）、用某种方式验证输入文本，或者执行计算
  ls-type:: annotation
  hl-page:: 171
  id:: 63721191-6d2c-4f77-85ae-14835af95446
- 7.4 标记备选分支以获取精确的事件方法
  ls-type:: annotation
  hl-page:: 171
  id:: 637211a1-f1b3-4214-9378-e6e08aa08070
- 7.5 在事件方法中共享信息
  ls-type:: annotation
  hl-page:: 174
  id:: 637213a1-662e-48e6-94ed-74336828dac9
- 编程实践应该使用传参和返回值，而非类成员或者其他的“全局变量”。但是，问题在于，ANTLR自动生成的监听器方法是不带自定义返回值和参数的。同样，ANTLR生成的访问器方法也不带自定义参数
  ls-type:: annotation
  hl-page:: 174
  id:: 637213c3-146c-474c-896e-c9f2cd71271e
- ==不改变事件方法签名的前提下，用它们来传递数据的机制==。
  hl-page:: 174
  ls-type:: annotation
  id:: 637213d7-52b9-450f-81db-16f3142aeacf
	- 三种方法实现上一节提到的，基于LExpr表达式语法的示例计算器程序。其中，
	- 第一种方法使用访问器方法来返回值，
	- 第二种使用类成员在事件方法之间共享数据，
	- 第三种通过对语法分析树的节点进行标注来存储相关数据
- 1.使用访问器遍历语法分析树 ---  visit实现里返回值
  ls-type:: annotation
  hl-page:: 174
  id:: 637213ff-818a-4149-97c2-e1e3ae5932e2
- 2.使用栈来模拟返回值  --- listenter里没有return， 通过栈丢进去，enter  exit的时候获取
  hl-page:: 176
  ls-type:: annotation
  id:: 63721459-b6f0-468a-85d8-2806b99887b3
- 3.标注（Annotate）语法分析树
  ls-type:: annotation
  hl-page:: 177
  id:: 63721499-e0ef-46df-83cb-83daf5ad2862
- 每个子表达式对应一个子树的根节点（同时对应一个e规则的调用）
  ls-type:: annotation
  hl-page:: 178
  id:: 637214d9-5884-4488-b160-b87f9ce9ca8d
- 不在乎将语法绑定在特定的编程语言上所引起灵活性丧失，我们可以简单地为特定规则添加一个返回值
  ls-type:: annotation
  hl-page:: 179
  id:: 637214ec-5278-423c-8e56-be95cb76d446
- [:span]
  ls-type:: annotation
  hl-page:: 179
  id:: 637214fc-4507-4379-ab49-4215b263ae56
  hl-type:: area
  hl-stamp:: 1668420859013
- 第8章 构建真实的语言类应用程序
  ls-type:: annotation
  hl-page:: 184
  id:: 6372151a-eb32-4ea1-9258-543c3b325065
- ，由浅入深地构造四个监听器（同样，我们也可以使用访问器
  ls-type:: annotation
  hl-page:: 184
  id:: 63721532-5492-47ea-81a3-f5972e254131
- 8.1 加载CSV数据
  ls-type:: annotation
  hl-page:: 185
  id:: 63721562-5b06-4caf-beef-c6168d6a7fc0
- 第三部分 高级特性
  ls-type:: annotation
  hl-page:: 210
  id:: 63721891-f06a-4054-a4a5-6578b49a3f84
- 第9章 错误报告与恢复
  ls-type:: annotation
  hl-page:: 210
  id:: 63721897-1a41-4786-818b-28ffd822b8bb
- 第10章 属性和动作
  ls-type:: annotation
  hl-page:: 248
  id:: 637218de-c2ca-41eb-bf8e-66ef69a000a9
- [:span]
  ls-type:: annotation
  hl-page:: 29
  id:: 63e7487d-1e76-4e4a-869d-21232e3c52b5
  hl-type:: area
  hl-stamp:: 1676101756811