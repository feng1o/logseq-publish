file-path:: ../assets/ddia_1641797656322_0.pdf

- ### **第一章： [[可靠性]]、[[可扩展性]]、[[可维护性]]**
  hl-page:: 8
  ls-type:: annotation
  id:: 624c69a6-a83f-4658-9178-a95230f95de3
  background-color:: #978626
  collapsed:: true
	- [[可靠性]] reliability
	  hl-page:: 29
	  ls-type:: annotation
	  id:: 624d0187-32c8-46b1-86ed-b02c0cec447f
		- [:span]
		  ls-type:: annotation
		  hl-page:: 29
		  id:: 6285c350-439f-4550-b537-5e1b443107f5
		  hl-type:: area
		  hl-stamp:: 1652933454619
		- [:span]
		  ls-type:: annotation
		  hl-page:: 11
		  id:: 624c6a63-2bea-494a-a536-d1b0566b8f26
		  hl-type:: area
		  hl-stamp:: 1649175139705
		- 硬件故障   磁盘坏块  断电 网络问题 ----》 硬件冗余  [[raid]]等
		  hl-page:: 30
		  ls-type:: annotation
		  id:: 627e2915-d6dc-406d-b4cf-70d88251f96a
			- [:span]
			  ls-type:: annotation
			  hl-page:: 13
			  id:: 620518bf-ab73-4774-8412-f117a0160fe3
			  hl-type:: area
			  hl-stamp:: 1644501182022
			- [:span]
			  ls-type:: annotation
			  hl-page:: 31
			  id:: 6285c43e-eaa3-46b1-8fbc-d6beb590c18d
			  hl-type:: area
			  hl-stamp:: 1652933691693
		- 人为错误
		  ls-type:: annotation
		  hl-page:: 13
		  id:: 6205187d-5f5c-4172-a736-021e9c69119b
	- [[可扩展性]] scalability
	  hl-page:: 32
	  ls-type:: annotation
	  id:: 6285c1c3-9b16-4d04-afe9-8387f92d6c95
		- [:span]
		  ls-type:: annotation
		  hl-page:: 32
		  id:: 6285c293-b780-4e3f-8e61-cfe672ab0c18
		  hl-type:: area
		  hl-stamp:: 1652933265330
		- 描述负载
		  hl-page:: 14
		  ls-type:: annotation
		  id:: 6214ccb2-dcac-4e3a-a6de-b5fa4f4828fb
			- 一些特定的参数、比如扇出能力
		- 描述性能
		  hl-page:: 15
		  ls-type:: annotation
		  id:: 623b4127-7b09-4839-9d73-da8b344751fb
			- [:span]
			  ls-type:: annotation
			  hl-page:: 16
			  id:: 623b42ab-00ef-462f-bb1c-434bc83960a7
			  hl-type:: area
			  hl-stamp:: 1648050856647
			- throughput/response time 使用百分位点，比如p90
			  hl-page:: 16
			  ls-type:: annotation
			  id:: 623b441a-d88b-4a50-a9fc-20aee3928ffc
			- 百分位点常用于[[SLA]]|[[SLO]]: service level objectives; SLA, servicelevel agreements
			  hl-page:: 17
			  ls-type:: annotation
			  id:: 623b4c93-4134-420d-8294-8ad6932dca1b
		- **应对负载的方法**
		  hl-page:: 18
		  ls-type:: annotation
		  id:: 623b4da5-a61c-4308-95c6-b681563b8799
			- 当负载+，如何保证良好性能？
		- ls-type:: annotation
		  hl-page:: 14
		  id:: 62051b49-5ca2-49dd-851b-82958d203bf5
	- [[可维护性]] Maintainability
	  hl-page:: 37
	  ls-type:: annotation
	  id:: 6285c2de-6a00-4219-adbf-784ddd3e94d1
	- 可操作性（Operability
	  ls-type:: annotation
	  hl-page:: 37
	  id:: 6285d764-f1ae-4b71-b7fc-c86567cbcbcd
	- 简单性（Simplicity）
	  ls-type:: annotation
	  hl-page:: 37
	  id:: 6285d769-9bf5-4101-9b67-a7fbbb273a11
		- 复杂度（complexity）有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等
		  hl-page:: 38
		  ls-type:: annotation
		  id:: 6285d7de-2714-449f-a54e-d7d09e1a3d75
		- 简单性：管理复杂度
		  hl-page:: 38
		  ls-type:: annotation
		  id:: 6285d7cf-0c8a-4a85-8355-906ee1852c59
		- 消除额外复杂度的最好⼯具之⼀一是抽象（abstraction）
		  ls-type:: annotation
		  hl-page:: 38
		  id:: 6285d7fe-0f9f-476a-8e69-cffe6e458fdb
	- 可演化性（evolability）
	  ls-type:: annotation
	  hl-page:: 37
	  id:: 6285d76c-2b2b-4230-b051-3f018e15a02d
		- 也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。
		  ls-type:: annotation
		  hl-page:: 37
		  id:: 6285d782-9ff7-4e5a-abb1-d87192155d65
-
- ### 第二章：[[数据模型]]与查询语⾔言
  hl-page:: 42
  ls-type:: annotation
  background-color:: #497d46
  id:: 6285d908-8a24-4e4e-9f3c-95d97e532705
	- 关系模型、⽂档模型、图形（三种模型)
	  hl-page:: 43
	  ls-type:: annotation
	  id:: 6285d8d4-5efb-4493-b943-ab7859a10814
		- 文档数据库和图数据库有⼀个共同点，那就是它们通常不会为存储的数据强制⼀个模式
	- NoSQL的诞⽣
	  hl-page:: 44
	  ls-type:: annotation
	  id:: 62aafdd8-7dea-4b69-85e7-2cba25899958
		- <span class=subw8>a.驱动因素：	比关系型扩展性，大数据集，高吞吐； 受挫于关系模型的限制性，渴望一种<span class=red>更具多动态性与表现力</span>的数据模型；特殊查询</span>
		- <span class=subw8>b.比如文档数据库：一个LinkedIn介绍，sql需要关联多个表，用户职业；文档就搞个json，array动态关联。 文档数据库就一条sql，树结构</span>
		- <span class="subw8">c.比如文档数据库具有更好地<span class=red>局部性</span></span>
	- ⽀持[[⽂档数据模型]]的主要论据是架构灵活性，因[[局部性]]⽽拥有更好的性能，
	  hl-page:: 51
	  ls-type:: annotation
	  id:: 62cd793a-005d-4981-bd78-e3efa67d5540
	- 哪个数据模型更方便写代码？
	  hl-page:: 51
	  ls-type:: annotation
	  id:: 62cd79cb-2956-4141-a983-e4bf9c4bc441
		- <span class="subw8">一对多，直接加载关系树；文档不方便访问其那套项目；多对多可能关系型更好</span>
	- 文档模型中架构的灵活性
		- ⽂档数据库有时称为==[[无模式]]==（schemaless），一个更更精确的术语是==[[读时模式]]==（schema-on-read）；==写时模式==（schema-on-write）（传统的关系数据库⽅方法中，模式明确，且数据库确保所有的数据都符合其模式）
		  hl-page:: 51
		  ls-type:: annotation
		  id:: 62cd7a39-7141-4277-b114-3832a10543e7
	- 查询的数据==局部性==
	  ls-type:: annotation
	  hl-page:: 52
	  id:: 62cd7afc-a6cc-43ba-9db1-f6b6840a2020
	- 数据查询语⾔(声明式  命令式)
	  hl-page:: 53
	  ls-type:: annotation
	  id:: 62cd7bb0-359f-4baa-8759-02dd99a63b59
		- ==声明式查询语⾔==言（如SQL或关系代数）中，你只需指定所需数据的模式 - 结果必须符合哪些条件，以及如何将数据转换（例例如，排序，分组和集合） - 但不不是如何实现这⼀一⽬目
		  ls-type:: annotation
		  hl-page:: 54
		  id:: 62cd7c0d-ac2f-481d-9d04-0f654e82e843
		- 申明式语⾔往适合并⾏执⾏
		  hl-page:: 54
		  ls-type:: annotation
		  id:: 62cd7c2f-e33c-4749-bec7-f165367de0e0
		-
	- 图数据模型
	  ls-type:: annotation
	  hl-page:: 58
	  id:: 62cd7ceb-60f6-4b5a-99ea-11018582b5ec
		- 一对多、或大多数之间无关系，可以用文档模型
		- 多对多关系型模型可以，但是数据量大了后就麻烦
	- 三元组存储和SPARQL
	  ls-type:: annotation
	  hl-page:: 63
	  id:: 62cd7dc9-a883-4918-bfe3-38816ead7bad
		- 语义⽹络
		  ls-type:: annotation
		  hl-page:: 64
		  id:: 62cd7e2c-7910-450c-a68b-d0b0bac7c45a
		- Datalog是⽐SPARQL或Cypher更古老的语⾔
		  hl-page:: 66
		  ls-type:: annotation
		  id:: 62cd7e59-3438-4d70-8c2b-9cff364beee6
	- 本章⼩结
	  ls-type:: annotation
	  hl-page:: 68
	  id:: 62cd7e78-c4a2-419a-a990-79f1c4ad33b8
		- 历史上，数据最开始被表示为⼀一棵⼤大树（层次数据模型），但是这不不利利于表示多对多的关系，所以发明了了关系模型来解决这个问题。最
		  ls-type:: annotation
		  hl-page:: 68
		  id:: 62cd7e9a-b517-4240-b069-1f5ab7e818e9
		- [:span]
		  ls-type:: annotation
		  hl-page:: 68
		  id:: 62cd7eae-04d9-4939-930c-0342fd11d632
		  hl-type:: area
		  hl-stamp:: 1657634475415
		- ⽂文档数据库和图数据库有⼀一个共同点，那就是它们通常不不会为存储的数据强制⼀一个模式
		  ls-type:: annotation
		  hl-page:: 69
		  hl-color:: red
		  id:: 65803777-cf28-4d41-a9f2-d743dd4960a0
- ### 第三章. 存储与检索
  hl-page:: 73
  ls-type:: annotation
  background-color:: #978626
  id:: 62cd7f23-02c9-43dc-aca1-2e83e41ec6f9
  heading:: true
	- <p class="gray subw9  inline_box underline"><span style="color: red;background-color: lightblue;font-weight:bold;font-size:12px"> 内容:</span>从数据库的视⻆角来讨论同样的问题：数据库如何存储我们提供的数据，以及如何在我们需要时重新找到数据</p>
	  hl-page:: 74
	  ls-type:: annotation
	  id:: 62cd7f7c-caaf-4b60-bd3b-65e681ea8291
	  hl-stamp:: 1702901761116
	  hl-color:: red
	- 究两⼤类存储引擎：==日志结构==（log-structured）的存储引擎，以及==面向页⾯==（page-oriented）(也叫tuple storage?15445) 的存储引擎（例如B树）
	  hl-page:: 74
	  ls-type:: annotation
	  id:: 62cd8059-8eea-4dde-967d-b96e8f46e438
	- SSTables和LSM树
	  hl-page:: 79
	  ls-type:: annotation
	  id:: 62cee053-b805-4dd6-85ac-e9045dabaad3
		- 排序字符串表（Sorted String Table），简称==[[SSTable]]==
		  hl-page:: 79
		  ls-type:: annotation
		  id:: 62cee14e-710e-416a-b9c0-e0a9d8e964f3
			- SSTable优势： <span class="subw8 bg-lightgray"><br>   1.简单高效、可合并比内存大很多的segment <br>   2.不需要内存中记录索引 </br>   3.可按块存，记录块头，压缩后减少io</span>
			- 构建和维护[[SSTables]]
			  hl-page:: 80
			  ls-type:: annotation
			  id:: 62cee27f-81ce-4439-a6a9-269a6b20b9f2
				- 内存内使用红黑树-内存表==[[memtable]]==
				- memtable写入一定阈值后，作为SSTable写入disk
				- 查找：memtable找，找不到disk就近seg，没继续深入
				- 后台compation
				- 问题：崩溃恢复，wal完成
		- ⽤==[[SSTables]]==制作[[LSM树]]log structured merged tree
		  hl-page:: 80
		  ls-type:: annotation
		  id:: 62cee441-7d1c-4c7e-985b-f0ea93124cb5
			- <span class=subw9>这⾥描述的算法本质上是[[LevelDB]] 【6】和[[RocksDB]] 【7】中使⽤用的[[关键]]值存储引擎库，被设计嵌⼊入到其他应⽤用程序中。除此之外，[[LevelDB]]可以在Riak中⽤用作Bitcask的替代品。在[[Cassandra]]和[[HBase]]中使⽤用了了类似的存储引擎【8】，这两种引擎都受到了了Google的Bigtable⽂文档【9】（引⼊入了了[[SSTable]]和memtable）的启发</span>
			  hl-page:: 81
			  ls-type:: annotation
			  id:: 62cee4cb-a465-40ae-833c-5f24965fec72
			- 于这种[[#red]]==合并和压缩排序文件==原理的存储引擎通常被称为==[[LSM存储引擎]]==
			  hl-page:: 81
			  ls-type:: annotation
			  id:: 62cee54a-8336-4e6e-aaea-b1d233d50262
			- 性能优化
			  ls-type:: annotation
			  hl-page:: 81
			  id:: 62cee5e2-4310-4bc0-9ff0-3dbdde30bd94
				- 当查找数据库中不不存在的键时，LSM树算法可能会很慢：
				  ls-type:: annotation
				  hl-page:: 81
				  id:: 62cee5f0-0635-4007-b1cb-f1d04b58ff90
				- SSTables如何被压缩和合并的顺序和时间。
				  ls-type:: annotation
				  hl-page:: 81
				  id:: 62cee5fd-8b34-4b18-84e9-6ca8d1886922
					- 大⼩小分层压实
					  ls-type:: annotation
					  hl-page:: 81
					  id:: 62cee605-aa64-4fe1-a391-8510577c4013
					- [[LevelDB]]和[[RocksDB]]使⽤用平坦压缩（LevelDB因此得名），[[HBase]]使⽤用⼤小分层
					  hl-page:: 81
					  ls-type:: annotation
					  id:: 62cee60b-7dd9-4fac-b1eb-352e86117c0f
			- ==[[LSM树]]==的基本思想：
			  hl-page:: 81
			  ls-type:: annotation
			  id:: 62cee666-8e21-451e-bff7-11d1abb42b3a
				- <span class="subw8 blue">保存⼀系列列在后台合并的SSTables — 简单⽽而有效。即使数据集⽐比可⽤用内存⼤大得多，它仍能继续正常⼯工作。由于数据按排序顺序存储，因此可以⾼高效地执⾏行行范围查询（扫描所有⾼高于某些最⼩小值和最⾼高值的所有键），并且因为磁盘写⼊入是连续的，所以LSM树可以⽀支持⾮非常⾼高的写⼊入吞吐量量</span>
			-
	- B树
	  ls-type:: annotation
	  hl-page:: 81
	  id:: 62d02eb8-590d-4723-9b53-f103dd6d7335
		- SSTables⼀一样，B树保持按键排序的键值对，这允许⾼效的键值查找和范围查询
		  ls-type:: annotation
		  hl-page:: 81
		  id:: 62d02f10-871c-4f4c-a8c5-d364e3eed944
		- B树将数据库分解成固定⼤小的块或⻚面，传统上⼤小为4KB, 一次只能读取或写⼊一个⻚
		  hl-page:: 81
		  ls-type:: annotation
		  id:: 62d02f2e-3d92-4cd4-8556-da8b479df471
		-
	- ⽐较B树和LSM树
	  ls-type:: annotation
	  hl-page:: 84
	  id:: 62d0305f-416c-40fa-9925-9f79178f6960
		- 通常LSM树的写入速度更快，⽽B树的读取速度更快.   LSM树上的读取通常⽐较慢，因为它们必须在压缩的不同阶段检查⼏个不同的数据结构和SSTables。
		  hl-page:: 84
		  ls-type:: annotation
		  id:: 62d03074-fa18-4a0f-b980-ea00d5ad0644
		- B树索引: 一次写得写redo和一个页面，可能跟新很少也得page写，还可能跨page； LSM树：反复compation和SStable过程也会rewrite data，这种影响：写入数据库导致多次磁盘写入称为==写放大(write amplification)==
		  hl-page:: 84
		  ls-type:: annotation
		  id:: 62d030b2-4402-4bcf-a15d-401872ef55d8
		- LSM树可以被压缩得更好，因此经常⽐B树在磁盘上产⽣更⼩的⽂件
		  hl-page:: 84
		  ls-type:: annotation
		  id:: 62d03170-ce94-46a7-a8e8-c8d0ff1d56d1
		-
	- [[LSM树]]的缺点
	  ls-type:: annotation
	  hl-page:: 85
	  id:: 62d031ce-1ebc-48f6-889c-f14b10c6a22a
		- 压缩过程有时会⼲扰正在进行的读写操作。
		  ls-type:: annotation
		  hl-page:: 85
		  id:: 62d031d7-2b51-4f15-b962-968440a78013
		- B树的行为则相对更具可预测性
		  hl-page:: 85
		  ls-type:: annotation
		  id:: 62d031f1-68cb-4cc2-a207-e63479f3939c
		- 压缩的另⼀个问题出现在⾼写⼊吞吐
		  hl-page:: 85
		  ls-type:: annotation
		  id:: 62d0321a-d6de-48e3-9321-2ab39265e852
		- 如果写⼊吞吐量量很⾼，并且压缩没有仔细配置，压缩跟不上写⼊，产生更多seg，查询需要检查更多段
		  hl-page:: 85
		  ls-type:: annotation
		  id:: 62d0322a-448c-4dff-afef-dd714fcae03d
		- B树的⼀个优点是每个键只存在于索引中的⼀个位置，⽽日志结构化的存储引擎可能在不同的段中有相同键的多个副本。这个⽅面使得B树在想要提供强⼤的事务语义的数据库中很有吸引力：在许多关系数据库中，事务隔离是通过在键范围上使⽤锁来实现的，在B树索引中，这些锁可以直接连接到树
		  hl-page:: 85
		  ls-type:: annotation
		  id:: 62d03269-a97f-4f48-85e9-2f584390aabc
	- 多列索引
	  ls-type:: annotation
	  hl-page:: 86
	  id:: 62d033b7-61f4-42da-8591-680c9eec8502
	- 全⽂搜索和模糊索引
	  ls-type:: annotation
	  hl-page:: 86
	  id:: 62d033f0-3b7d-4042-a62e-b9041a17dd47
		- 在内存中存储⼀切
		  ls-type:: annotation
		  hl-page:: 87
		  id:: 62d03463-928a-4d00-b252-41cd3284b46a
			- 更快的原因在于省去了了将内存数据结构编码为磁盘数据结构的开销
			  ls-type:: annotation
			  hl-page:: 87
			  id:: 62d034b5-8cbb-4093-97ca-7408d62a7265
	- ==如果⾮易失性存储器器（NVM）技术得到更⼴泛的应⽤用，可能还需要进⼀一步改变存储引擎设计【46】。目前这是⼀个新的研究领域，值得关注==
	  hl-page:: 88
	  ls-type:: annotation
	  id:: 62d034f4-f37b-45a9-b6b3-dfa025621ea2
		- 事务处理还是分析？
		  ls-type:: annotation
		  hl-page:: 88
		  id:: 62d03536-2dd9-4501-bbe1-4703bcc322f5
		- 数据仓库
		  ls-type:: annotation
		  hl-page:: 88
		  id:: 62d2e7ef-7cf6-4422-ad2b-6f0497af3ca3
			- ==ETL== 从OLTP数据库中提取数据（使⽤定期的数据转储或连续的更新流），转换成适合分析的模式，清理并加载到数据仓库中。将数据存⼊仓库的过程称为“抽==取-转换-加载（ETL）==
			  hl-page:: 89
			  ls-type:: annotation
			  id:: 62d2e829-cfcc-4ea9-8a78-7e8705e72122
			- 列存储
			  ls-type:: annotation
			  hl-page:: 92
			  id:: 62d2e8f9-03fc-4d7a-b0c2-2f2650b81f2f
				- 列压缩
				  ls-type:: annotation
				  hl-page:: 93
				  id:: 62d2e94c-f7f3-427d-85cb-bd5709610c81
					- 列存储中的排序顺
					  hl-page:: 95
					  ls-type:: annotation
					  id:: 62d2e9a5-9ccc-4eb2-9a20-7e05384b33ba
						- 列独自排序是没有意义的，
						  hl-page:: 95
						  ls-type:: annotation
						  id:: 62d2e9ba-ff92-4cb5-bc79-80d05e9979b7
						-
					- 列存储中，通常在其他地方没有任何指向数据的指针，只有包含值的列
					  hl-page:: 96
					  ls-type:: annotation
					  id:: 62d2ea3d-360e-4f32-affb-24e44d16978b
			- 聚合：数据⽴方体和物化视图
			  ls-type:: annotation
			  hl-page:: 96
			  id:: 62d2ea8a-b9f2-4e6b-8db2-c302727da718
				- 物化视图是查询结果的实际副本，写入磁盘，⽽虚拟视图只是写入查询的捷
				  hl-page:: 96
				  ls-type:: annotation
				  id:: 62d2eabc-6f36-4596-a487-9d5d068201d8
		- 本章小结
		  hl-page:: 97
		  ls-type:: annotation
		  id:: 62d2eafc-f5ff-4d2a-a4e9-e439047e2cca
-
- ### 第四章. 编码与演化
  hl-page:: 102
  ls-type:: annotation
  id:: 62d2ebe6-9b72-4fa5-88a4-66fd8a4edb4f
  background-color:: #978626
	- 双向兼容性
	  ls-type:: annotation
	  hl-page:: 103
	  id:: 62d2ec82-bdb5-41ff-8a99-9afe5a8794ec
		- 向后兼容 (backward compatibility)新代码可以读旧数据。向前兼容 (forward compatibility)旧代码可以读新数据。
		  ls-type:: annotation
		  hl-page:: 103
		  id:: 62d2ec88-9041-4235-b5c1-7c8eefb08cea
		- 编码数据的格式
		  ls-type:: annotation
		  hl-page:: 104
		  id:: 62d69e87-435f-4eca-90d2-e16ce3d2220c
			- 从内存中表示到字节序列的转换称为***编码***（Encoding）（也称为==序列化==（serialization）或编组（marshalling）），反过来称为**解码**（Decoding）2（解析（Parsing），==反序列化==（deserialization）
			  hl-page:: 104
			  ls-type:: annotation
			  id:: 62d69ebf-0bd1-41c3-abed-3bb1637a10dd
		- 所有的JSON的⼆进制编码在这⽅方⾯面是相似的。空间节省了了⼀丁点（以及解析加速）是否能弥补可读性的损失，谁也说不不准。
		  hl-page:: 106
		  ls-type:: annotation
		  id:: 62d6a170-56ed-4ad0-abe9-590952b0350e
	- Thrift与Protocol Buffers
	  ls-type:: annotation
	  hl-page:: 107
	  id:: 62d6a1b7-2de3-4354-90b5-fbd72593930b
		- Thrift和Protocol Buffers都需要==⼀个模式来编码任何数据==(thrift接口定义语言IDL)
		  hl-page:: 107
		  ls-type:: annotation
		  id:: 62d6a1c5-62d7-4436-8015-b2b128b71147
		- pb里是没key名字：最⼤的区别是没有字段名，包含字段标记数字；模式中required不影响编解码
		  hl-page:: 108
		  ls-type:: annotation
	- ==字段标签==和==模式演变==
	  hl-page:: 110
	  ls-type:: annotation
	  id:: 62d6a313-0618-404a-ab50-fe7bd2b24910
		- Thrift和Protocol Buffers如何处理理模式更改，同时保持向后兼容性？
		  ls-type:: annotation
		  hl-page:: 110
		  id:: 62d6a322-4e2e-4647-8357-86f1f9bee1c0
			- 字段由标签号码表示，并用数据类型注释；没设置字段值就忽略；您可以更更改架构中字段的名称，因为编码的数据永远不会引⽤字段名称，但不能更改字段的标记(数字1.2....)
			  hl-page:: 110
			  ls-type:: annotation
			  id:: 62d6a3bd-1b9b-4178-9c3b-669e1acc3ca8
			- 前向兼容
			  ls-type:: annotation
			  hl-page:: 110
			  id:: 62d6a472-c1c5-4867-bb42-b58bf5848b46
				- 加字段：价格标签号127.x.0.1....；旧的代码读取新代码写的数据包含新字段，标签号不能识别，简单忽略即可
			- 向后兼容性
			  ls-type:: annotation
			  hl-page:: 110
			  id:: 62d6a4a0-be72-4d9a-9539-ef1162f3c47c
				- 新代码加的字段必须是可选或者有默认值即可，老的代码写入的数据读不到
			- 删除⼀个字段就像添加⼀个字段，倒退和向前兼容性问题相反。这意味着您只能删除⼀一个可选的字段（必填字段永远不能删除），⽽且您不不能再次使⽤用相同的标签号码（因为您可能仍然有数据写在包含旧标签号码的地⽅方，⽽而该字段必须被新代码忽略略
			  hl-page:: 110
			  ls-type:: annotation
			  id:: 62d6a4ed-6351-4ea8-87c4-e0c0cdc861f8
	- ==数据类型==和==模式演变==
	  hl-page:: 111
	  ls-type:: annotation
	  id:: 62d6a50c-d0c8-4b61-bd40-e753ef2a08cf
		- 字段类型改变：可能的，但是有风险，失去精度或被扼杀。32-64位整数，新的读旧的0加，旧的读新的可能会移除或截断
		- [[Protobuf]]的⼀个奇怪的细节是，它没有列表或数组数据类型，而是有⼀个字段的重复标记（这是第三个选项旁边必要和可选
		  hl-page:: 111
		  ls-type:: annotation
		  id:: 62d6a616-aee4-46ab-ae90-0d6198e4a887
			- 重复字段的编码正如它所说的那样：同⼀一个字段标记只是简单地出现在记录中。这具有很好的效果，可以将可选（单值）字段更更改为重复（多值）字段。读取旧数据的新代码会看到⼀一个包含零个或⼀一个元素的列列表（取决于该字段是否存在）。读取新数据的旧代码只能看到列列表的最后⼀一个元素。
			  ls-type:: annotation
			  hl-page:: 111
			  id:: 62d6a642-0ad0-42e2-b15c-ca5a11251081
	- Avro
	  ls-type:: annotation
	  hl-page:: 111
	  id:: 62d6a664-5e1e-4f60-b561-dbeb2377ae28
		- Avro也使用模式来指定正在编码的数据的结构。它有两种模式语⾔言：一种（Avro IDL）⽤于⼈工编辑，⼀种（基于JSON），更易于机器读取
		  hl-page:: 111
		  ls-type:: annotation
		  id:: 62d6a694-4fbe-4918-8b72-5b37fd3fc116
		- 作者模式与读者模式
		  ls-type:: annotation
		  hl-page:: 112
		  id:: 62dd5eff-0c2d-428a-a7df-891f13be5d8e
			- Avro的关键思想是作者的模式和读者的模式不不必是相同的 - 他们只需要兼容
			  ls-type:: annotation
			  hl-page:: 112
			  id:: 62dd5f06-3ea9-4dcc-a6a1-82fdba1e7038
		- 模式演变规则
		  ls-type:: annotation
		  hl-page:: 113
		  id:: 62dd5f71-acb0-4b5c-8072-49dc50ee2d42
	- 模式的优点
	  ls-type:: annotation
	  hl-page:: 114
	  id:: 62dd603d-2fdc-4570-9934-453581fd19b3
		- [:span]
		  ls-type:: annotation
		  hl-page:: 115
		  id:: 62de24e2-5563-4939-897f-6e2bba9ac0f1
		  hl-type:: area
		  hl-stamp:: 1658725645623
	- 数据流的类型
	  ls-type:: annotation
	  hl-page:: 115
	  id:: 62de254d-e8fb-411d-83be-864c99fad45c
		- ⾯向服务的体系结构（service-oriented architecture，==SOA==），最近被改进和更更名为微服务架构
		  hl-page:: 117
		  ls-type:: annotation
		  id:: 62de2671-d2f4-4220-a85e-286246bfd59c
			- ⾯向服务/微服务架构的⼀一个关键设计⽬标是通过使服务独⽴部署和演化来使应⽤程序更易于更改和维护
			  hl-page:: 118
			  ls-type:: annotation
			  id:: 62de2691-6d4e-40f1-bbd0-0740f342fc5f
		- REST不是一个协议，⽽是⼀个基于HTTP原则的设计哲学
		  hl-page:: 118
		  ls-type:: annotation
		  id:: 62de26dd-f49c-42a5-a24e-e32a86ce929d
	- 远程过程调⽤用（[[RPC]]）的问题
	  ls-type:: annotation
	  hl-page:: 118
	  id:: 62de2732-3737-493f-97a7-621573807651
		- RPC起初看起来很方便便，但这种⽅方法根本上是有缺陷的【43,44】。⽹络请求与本地函数调⽤⾮常不同 : <span class=subw> 不可预测，本地可预测延时问题，序列化问题，转换问题</span>
		  hl-page:: 119
		  ls-type:: annotation
		  id:: 62de276d-85a3-404f-bc60-fe1ee8bf4a5d
		- RPC的当前⽅向
		  ls-type:: annotation
		  hl-page:: 119
		  id:: 62de27e3-00da-4690-aad6-6a7c7f0c12c5
			- REST似乎是公共API的主要⻛风格。 RPC框架的主要重点在于同⼀一组织拥有的服务之间的请求，通常在同⼀一数据中⼼心
			  ls-type:: annotation
			  hl-page:: 120
			  id:: 62de28e8-74e4-491f-a9de-a1bda0b9876c
		- 数据编码与RPC的演化
		  ls-type:: annotation
		  hl-page:: 120
		  id:: 62de28ef-1e96-4ec2-bceb-ad31f715f06f
	- 消息传递中的数据流
	  ls-type:: annotation
	  hl-page:: 120
	  id:: 62de2976-fcb5-4299-9271-c42a4c23e30d
		- 分布式的Actor框架
		  ls-type:: annotation
		  hl-page:: 121
		  id:: 62de8216-7f79-43a8-a89b-34b0581f0a57
			- [[Actor/模型]]是单个进程中[[并发模型]]。逻辑被封装在⻆色中，⽽不是直接处理线程（以及竞争条件，锁定和死锁的相关问题）。每个⻆色通常代表⼀个客户或实体，它可能有⼀些本地状态（不与其他任何角⾊共享），它通过发送和接收异步消息与其他⻆色通信。消息传送不保证：在某些错误情况下，消息将丢失。由于每个⻆色⼀次只能处理一条消息，因此不需要担⼼线程，每个⻆色可以由框架独⽴调度。
			  hl-page:: 121
			  ls-type:: annotation
			  id:: 62de826b-818f-4536-9587-05d5e7e70625
	- 三个流⾏的分布式actor框架处理理消息编码如下：
	  hl-page:: 121
	  ls-type:: annotation
	  id:: 62de8298-d816-4dbc-aa04-91cd5ae5a5f2
		- 本章⼩小结
		  ls-type:: annotation
		  hl-page:: 122
		  id:: 62de82a5-0f39-4830-9c81-24ca5378501c
-
- ### 第⼆部分：分布式数据
  hl-page:: 125
  ls-type:: annotation
  background-color:: #497d46
  id:: 62de834c-bfa1-4e3e-8204-43fa64a0a5ef
	- 复制 vs 分区
	  ls-type:: annotation
	  hl-page:: 126
	  id:: 62de8454-5487-4751-8263-be44919ed28b
		- <span class=subw>在⼏个不同的节点上保存数据的相同副本，可能放在不同的位置。复制提供了冗余;<br>将⼀个大型数据库拆分成较⼩的子集（称为分区（partitions）），从⽽不同的分区可以指派给不同的节点（node）（亦称分⽚片（shard））</span>
		  hl-page:: 126
		  ls-type:: annotation
		  id:: 62de84b8-41ff-40b0-9d4c-e418e50cf972
-
- ### 第五章: 复制
  hl-page:: 128
  ls-type:: annotation
  id:: 62de8587-b535-4583-b908-0e37f9ad599b
  background-color:: #978626
	- replicate不是一次copy就ok，否则很easy；将讨论三种流⾏的变更复制算法：
		- <span class=blue>单领导者（single leader）    多领导者（multi leader）     无领导者（leaderless)</span>
	- 复制时需要进行许多权衡
	  hl-page:: 130
	  ls-type:: annotation
	  id:: 62de8666-b255-486d-b850-7b1f0d9090ee
		- 如，使⽤用同步复制还是异步复制？如何处理理失败的副本
		  ls-type:: annotation
		  hl-page:: 130
		  id:: 62de8673-bb2b-45b1-aa0c-f5590a6647a0
	- <a class="ask">领导者与追随者</a>
	  hl-page:: 130
	  ls-type:: annotation
	  id:: 62de86a7-f0e8-40e3-8e9a-3893e5a21c8a
		- <a class=ask >如何确保所有数据都落在了所有的副本上？</a>
		  hl-page:: 130
		  ls-type:: annotation
		  id:: 62de86bc-18c9-49a5-b537-f22bd1a360f2
		- 常⻅的解决⽅方案被称为基于领导者的复制（leader-based replication）（也称主动/被动（active/passive）或主/从（master/slave）复制）
		  ls-type:: annotation
		  hl-page:: 130
		  id:: 62de86d9-2c40-4f6f-aa9e-619ef8d3144d
	- 同步复制与异步复制
	  ls-type:: annotation
	  hl-page:: 131
	  id:: 62de870e-b35d-477a-83c4-9e1ea1c35b57
		- 同步复制优点明显，但是缺点无法容忍，一般采用异步复制；弱化写入持久性，折中这个能力
	- 设置新从库
	  ls-type:: annotation
	  hl-page:: 132
	  id:: 62de87c9-ae8f-45fe-a587-796b35fccfa4
		- <a class=ask>如何确保新的从库拥有主库数据的精确副本</a> 通过snapshot
		  hl-page:: 132
		  ls-type:: annotation
		  id:: 62de89a7-d29c-4e8a-a382-49c0236c4ad6
	- 处理理节点宕机
	  ls-type:: annotation
	  hl-page:: 133
	  id:: 62de8a0f-fc48-4721-ad5a-e91c82ccd058
		- 如 <a class=ask>何通过基于主库的复制实现高可⽤</a>
		  hl-page:: 133
		  ls-type:: annotation
		  id:: 62de8a32-83fe-4f94-8c24-f74a9ed0b363
		- slave异常：拉起继续
		- master失效： failover切换
			- 故障切换会出现很多⼤麻烦：1.异步复制，可能丢数据，一般选择接受；2.[[脑裂]]split brain多个认为自己是master；3.避免不必要切换，且及时发现的牟盾问题
			  hl-page:: 133
			  ls-type:: annotation
			  id:: 62de8ada-cf58-44f2-b37e-cbe047c4a1f5
	- 复制⽇志的实现
	  ls-type:: annotation
	  hl-page:: 134
	  id:: 62de8b49-e930-4ea8-b94a-642ff9069917
		- 基 <a class=ask>于主库的复制底层是如何⼯作的</a>
		  hl-page:: 134
		  ls-type:: annotation
		  id:: 62de8b5a-2bb9-454c-bd09-4a77a71d72b9
		- 基于语句的复制 -- sql语句很多不确定性-在slave上效果不同
		  hl-page:: 134
		  ls-type:: annotation
		  id:: 62de8b96-055f-4709-ae75-49cc320c25d6
		- 传输预写式日志（WAL）-- pg
		  hl-page:: 134
		  ls-type:: annotation
		  id:: 62de8b99-8dcf-4e69-a334-79ea8f80b2b3
		- 逻辑⽇志复制（基于行）  --  mysql
		  hl-page:: 135
		  ls-type:: annotation
		  id:: 62de8bfb-be18-44a4-beba-9cdb698d485a
		- [[#red]]==基于触发器的复制==
		  hl-page:: 135
		  ls-type:: annotation
		  id:: 62de8c4e-4da2-4c29-824a-7381ba2bfc3b
	- 复制延迟问题
	  ls-type:: annotation
	  hl-page:: 136
	  id:: 62de8c83-e19e-4785-a292-9f7763796f3f
		- 读⼰之写: 业务测保证，用户自己能改的从master读，保证读己之写一致
		  hl-page:: 136
		  ls-type:: annotation
		  id:: 62debb4f-ade3-473f-8058-888b0c738d0e
		- 单调读：就是多个slave可能有的延迟更大，那就不要让他随机读，只读固定的保证不会倒退
		  hl-page:: 138
		  ls-type:: annotation
		  id:: 62debb90-91f2-4ec2-9cde-ce43ba06f92e
		- ⼀致前缀读： 简单理解就是比如分区、shared内部有序，有些前后关系的内容放在一个shared
		  hl-page:: 138
		  ls-type:: annotation
		  id:: 62debbb4-eb71-4816-a69f-f7d5f0fa4b1e
	- 多主复制
	  ls-type:: annotation
	  hl-page:: 140
	  id:: 62debd4f-ab3f-43e2-bc51-586b781f0fb3
		- 这里最大问题就是冲突怎么解决？ 延迟一致 ？ 或者
		- ⾃定义冲突解决逻辑
		  ls-type:: annotation
		  hl-page:: 144
		  id:: 62e1509a-58df-4fc7-ade7-c08bf768444d
		- 写时执⾏
		  ls-type:: annotation
		  hl-page:: 144
		  id:: 62e150c8-f968-46c6-b80b-bde176043487
			- 只要数据库系统检测到复制更更改⽇日志中存在冲突，就会调⽤用冲突处理理程序
			  ls-type:: annotation
			  hl-page:: 144
			  id:: 62e150cf-7946-446b-91b7-8974446ee126
		- 读时执⾏
		  ls-type:: annotation
		  hl-page:: 144
		  id:: 62e150d3-4b73-43e1-87a2-00edf482186b
			- 当检测到冲突时，所有冲突写⼊入被存储。下⼀一次读取数据时，会将这些多个版本的数据返回给应⽤用程序。应⽤用程序可能会提示⽤用户或⾃自动解决冲突，并将结果写回数据库。例例如，CouchDB以这种⽅方式⼯工作。
			  ls-type:: annotation
			  hl-page:: 144
			  id:: 62e150d7-e0ee-4155-873e-90caf3f6cecd
	- 多主复制拓拓扑
	  ls-type:: annotation
	  hl-page:: 145
	  id:: 62e1517b-7f0f-47c3-b9cb-b84d0c6ca404
	- ⽆主复制 Tosee #20231220
	  hl-page:: 146
	  ls-type:: annotation
	  id:: 62e15193-d39c-4e5e-bc0b-36ecb969ae02
		- 在⼀些⽆领导者的实现中，客户端直接将写⼊发送到⼏个副本中，⽽另一些情况下，⼀个协调者（coordinator）节点代表客户端进行写⼊
		  hl-page:: 147
		  ls-type:: annotation
		  id:: 62e151bd-020b-4bed-9b3d-8cdbdc970f30
		- 读修复和反熵  某个节点落后怎么修复
		  hl-page:: 147
		  ls-type:: annotation
		  id:: 62e15228-7dd3-4caa-8177-28e337087e86
		- 读写的法定⼈数
		  ls-type:: annotation
		  hl-page:: 148
		  id:: 62e15245-3011-412d-a565-b3bc4c70a534
		- Cassandra和Voldemort在正常的无主模型中实了他们的多数据中心⽀支持
		  hl-page:: 151
		  ls-type:: annotation
		  id:: 62e152a8-33b8-4007-bde3-6323b6c16192
		- 合并同时写⼊的值
		  ls-type:: annotation
		  hl-page:: 155
		  id:: 62e152e6-f77a-4eb6-a2bc-6a62d4f46674
	- 本章⼩结
	  ls-type:: annotation
	  hl-page:: 156
	  id:: 62e152f9-0823-47bc-a20e-fa861ed3334e
-
- ### 第六章：分区
  hl-page:: 161
  ls-type:: annotation
  id:: 62e15358-28e8-40fd-939f-79b25b7eaa4d
  background-color:: #978626
	- [:span]
	  ls-type:: annotation
	  hl-page:: 162
	  id:: 62e1543b-da68-4252-ade4-bbbabc28441b
	  hl-type:: area
	  hl-stamp:: 1658934330135
	- 分区与复制
	  ls-type:: annotation
	  hl-page:: 162
	  id:: 62e15479-58fb-47ab-bf45-c024bf659967
		- 怎么分，怎么保持均衡，避免[[数据倾斜]]skew及[[hot spot]]
		- Key散列进行分区，我们失去了键范围分区的一个很好的属性：⾼效执行范围查询的能⼒
		  hl-page:: 165
		  ls-type:: annotation
		  id:: 62f1ecf9-87de-4565-95bc-9ffe3672e845
	- 负载倾斜与消除热点
	  ls-type:: annotation
	  hl-page:: 165
	  id:: 630a08a4-e606-4bcc-9bf1-958b05df599e
	- 分⽚与次级索引
	  ls-type:: annotation
	  hl-page:: 166
	  id:: 630a2d86-d6bf-471f-989b-aacc7fc2ed76
		- 辅助索引通常并不能唯⼀地标识记录，⽽是⼀种搜索记录中出现特定值的方式
		  hl-page:: 166
		  ls-type:: annotation
		  id:: 630a2dd3-4198-4477-bf8e-fadd215237d7
	- ⽤二级索引对数据库进行分区的⽅方法：==[[基于文档的分区]]==（document-based）和==[[基于关键词的分区]]（term-based）的分区==
	  hl-page:: 166
	  ls-type:: annotation
	  id:: 630a2ddf-b556-4a76-ade1-dbe76a1bd567
		- ⽂档分区索引也被称为 [[本地索引/local index]]
		  hl-page:: 167
		  ls-type:: annotation
		  id:: 630a2e5e-fdb2-430b-b829-68a32188a9b6
		- 根据关键词(Term)的二级索引
		  ls-type:: annotation
		  hl-page:: 167
		  id:: 6310ced8-d310-47dd-8183-eea019e66be2
			- 在实践中，对全局⼆级索引的更新通常是异步的
			  hl-page:: 168
			  ls-type:: annotation
			  id:: 6310cf61-b809-4c0e-887d-22cc156c6a41
	- 分区再平衡
	  ls-type:: annotation
	  hl-page:: 168
	  id:: 6310cf6a-7cfa-4c2c-9ec0-df11212323eb
		- 将负载从集群中的⼀个节点向另一个节点移动的过程称为再平衡（==reblancing==）
		  hl-page:: 168
		  ls-type:: annotation
		  id:: 6310cf7f-7880-4b73-9a32-edf2f359d6a4
		- 平衡策略
		  ls-type:: annotation
		  hl-page:: 169
		  id:: 6310cfd1-fa9d-4d8c-9760-22f2a1dbc3e3
			- 反⾯教材：hash mod N
			  ls-type:: annotation
			  hl-page:: 169
			  id:: 6310d027-390f-45eb-839a-62855856758b
			- 固定数量的分区
			  ls-type:: annotation
			  hl-page:: 169
			  id:: 6310d031-380e-4852-a0cf-088ed0914c63
			- 按节点⽐例分区
			  ls-type:: annotation
			  hl-page:: 171
			  id:: 6310d06d-76f5-4fb3-8e3c-eb76461a3531
	- 请求路路由
	  ls-type:: annotation
	  hl-page:: 171
	  id:: 6310d07c-2095-4072-8093-3d9aae26ae03
		- 这个问题可以概括为[[服务发现]](service discovery)
		  ls-type:: annotation
		  hl-page:: 172
		  id:: 6310d0d3-5bef-41c8-acfb-7f2db80513ea
		- 许多分布式数据系统都依赖于⼀一个独⽴立的协调服务，
		  ls-type:: annotation
		  hl-page:: 172
		  id:: 6310d0f7-c16d-4e72-9232-561d621eec65
		- Cassandra和Riak采取不不同的⽅方法：他们在节点之间使用[[流⾔协议]]（gossip protocol）来传播群集状态的变化
		  hl-page:: 173
		  ls-type:: annotation
		  id:: 6310d127-c0cb-40f4-9dfb-7eeb52c808d8
	- 执并行查询
	  hl-page:: 173
	  ls-type:: annotation
	  id:: 6310d149-b93c-4162-bf01-198ea7047b49
	- 本章⼩小结
	  ls-type:: annotation
	  hl-page:: 173
	  id:: 6310d1fb-1511-4893-92ea-7e2886689e0f
-
- ### 7. [[事务]]
  ls-type:: annotation
  hl-page:: 177
  id:: 6310d22e-a0e1-406b-82e4-fc42bfe35591
  background-color:: #978626
	- 在数据系统的残酷现实中，很多事情都可能出错：
	  ls-type:: annotation
	  hl-page:: 179
	  id:: 6313256b-e60b-41e3-8feb-87b3c74f7437
		- 软硬件fault、app崩溃、net问题、并发写入问题、读取数据不一致、竞争问题
	- [[ACID]]的含义
	  ls-type:: annotation
	  hl-page:: 180
	  id:: 63133c38-5bca-4c3f-b886-738d620f34b2
		- 不符合ACID标准的系统有时被称为[[BASE]]，它代表基本可⽤性（Basically Available），软状态（Soft State）和[[最终⼀致性]]（Eventual consistency
		  hl-page:: 180
		  ls-type:: annotation
		  id:: 63133c3d-8873-4717-9085-75f3ccd3cacd
		- [[原子性]]（Atomicity）  [[undo log]]
		  hl-page:: 180
		  ls-type:: annotation
		  id:: 63133c7d-760b-4216-adf2-42319ae97723
			- 能够在错误时中止事务，丢弃该事务进行的所有写入变更更的能力。
			  hl-page:: 180
			  ls-type:: annotation
			  id:: 63133d25-7c85-46e8-920c-5fe47077b124
		- [[⼀致性]]（Consistency ： 数据库里指一个确定状态到另外一个，AID保证
		  hl-page:: 180
		  ls-type:: annotation
		  id:: 63134aaf-ace1-41c4-bf1f-8f099f0e9d5d
		- [[隔离性]]（Isolation） 写锁、读写[[MVCC]]
		  hl-page:: 181
		  ls-type:: annotation
		  id:: 631352ba-d1c3-4a03-8228-64b1966c07ea
			- 同时执⾏的事务是相互隔离的：它们不能相互冒
			  hl-page:: 181
			  ls-type:: annotation
			  id:: 63135302-6c64-4b32-acc7-008c68468dbf
		- [[持久性]]（Durability） [[redo log]]
		  hl-page:: 182
		  ls-type:: annotation
		  id:: 63135319-da50-46e7-83dd-37ca7a34fe9b
	- 单对象和多对象操作
	  ls-type:: annotation
	  hl-page:: 182
	  id:: 6332c87a-e662-49f0-b578-269c9bc2b57b
		- 多对象事务的需求
		  ls-type:: annotation
		  hl-page:: 184
		  id:: 6334feca-1fcd-46ff-a83d-df81de24ca8c
		- 许多分布式数据存储已经放弃了多对象事务，因为多对象事务很难跨分区实现，⽽
		  ls-type:: annotation
		  hl-page:: 184
		  id:: 6334fed5-ca07-4d7b-b909-9c28ffdc889c
	- 处理理错误和中⽌
	  ls-type:: annotation
	  hl-page:: 184
	  id:: 6334ff11-54fc-4f06-8cc0-58618f4d9423
	- 弱隔离级别
	  ls-type:: annotation
	  hl-page:: 185
	  id:: 634b8923-319b-43c9-bf1c-4206e17fa6ad
		- 读已提交 ： 没有脏读脏写
		  hl-page:: 186
		  ls-type:: annotation
		  id:: 634b8939-5a98-4d89-b520-7e496a871932
			- 读已提交是⼀个⾮常流行的隔离级
			  hl-page:: 187
			  ls-type:: annotation
			  id:: 634b8cf7-5473-4014-9c4d-26bda3b38ac3
		- [[快照隔离]]和[[可重复读]]
		  hl-page:: 188
		  ls-type:: annotation
		  id:: 634c0ee9-ad03-4639-a279-607e6f166230
			- <span class=subw>读提交虽然在应用中最终看是ok的；但是，在：==备份== 、分析查询和完整性检查时是不能容忍的</span>
			- 实现快照隔离 
			  hl-page:: 189
			  ls-type:: annotation
			  id:: 634c0fbf-8106-49bc-8196-b86bb4826de8
				- -:: 快照隔离的实现通常使⽤写锁来防止脏写
				- 从性能的⻆角度来看，[[快照隔离]]的⼀个关键原则是：==读不阻塞写，写不阻塞读==
				  hl-page:: 189
				  ls-type:: annotation
				  id:: 634c0ff3-adcc-4dc2-866e-158f57f33e35
			- ==多版本并发控制==（[[MVCC]], multi-version concurrentcy control）
			  ls-type:: annotation
			  hl-page:: 189
			  id:: 634c1048-dc67-4534-9098-d5d3bfe6c15c
			- 观察⼀一致性快照的可⻅见性规则
			  ls-type:: annotation
			  hl-page:: 190
			  id:: 634c112d-91e7-42f8-a282-2d51aabf7321
			- 索引和快照隔离
			  ls-type:: annotation
			  hl-page:: 191
			  id:: 634c1177-0cdb-4032-9cf9-8d1fa2dcb72a
				- <span class=ask>索引如何在多版本数据库中⼯工作</span>
				  hl-page:: 191
				  ls-type:: annotation
				  id:: 634c11b9-5c65-427e-87a1-c6cc16f9d56e
			- [[可重复读]]与命名混淆 --- 实际就是[[快照]]隔离
			  ls-type:: annotation
			  hl-page:: 191
			  id:: 634c1214-a5b9-4e47-97b1-1f126e31ac72
			- 防⽌丢失更新
			  hl-page:: 191
			  ls-type:: annotation
			  id:: 634c1252-1cbf-4f11-9dba-9e8b3ecc152e
				- ?:: 这里只是幻读中一种影响，确实是幻读：可以将写入偏差视为丢失更新问题的⼀一般化。如果两个事务读取相同的对象，然后更新其中⼀些对象（不同的事务可能更新不同的对象），则可能发生写⼊偏差。在多个事务更新同⼀个对象的特殊情况下，就会发⽣脏写或丢失更更新（取决于时机
				- 原⼦写
				  ls-type:: annotation
				  hl-page:: 192
				  id:: 634c12f0-bc98-4375-bb4a-7a3db3d4192a
				- 显式锁定
				  ls-type:: annotation
				  hl-page:: 192
				  id:: 634c1315-9b1d-420c-a3ea-315c9942a7be
				- ⾃动检测丢失的更更新
				  ls-type:: annotation
				  hl-page:: 193
				  id:: 634c1333-fa1a-485f-a326-dcd30054e93f
				- ⽐较并设置（CAS
				  ls-type:: annotation
				  hl-page:: 193
				  id:: 634c136e-2f64-4c82-b00e-3052cf8e5fa2
				- 冲突解决和复制： 在复制多节点上，可能某些node没更新
				  hl-page:: 193
				  ls-type:: annotation
				  id:: 634c1389-e922-4fc3-ba88-5896de64c991
			- 写⼊偏差(多个事务更新不同对象、非一个)与[[幻读]]
			  hl-page:: 194
			  ls-type:: annotation
			  id:: 634c140d-21a1-4c43-bbf8-aa73f47a67cf
				- 例子:: 比如两个doctor，至少有一个值班，同时发起判定发现now has two doctors； then发起更新自己数据下班
				- 可以将写⼊偏差视为丢失更更新问题的⼀般化。如果两个事务读取相同的对象，然后更更新其中⼀些对象（不同的事务可能更更新不同的对象 - [[写入偏差]]），则可能发⽣生写⼊偏差。在多个事务更更新同⼀个对象的特殊情况下，就会发生脏写或丢失更新（取决于时机）。
				  hl-page:: 195
				  ls-type:: annotation
				  id:: 634c1545-9743-4e7e-b38f-e628a58f5547
				- 由于涉及多个对象，单对象的原⼦操作不起作用。
				  hl-page:: 195
				  ls-type:: annotation
				  id:: 634c15b2-0aa4-4688-bc84-1b2311214320
				- 导致写入偏差的幻读
				  ls-type:: annotation
				  hl-page:: 196
				  id:: 634c1639-adaa-4227-9352-583149d81834
				- ==幻读phantoms：== [[间隙锁]] [[gap锁]] [[MySQL锁]] #interview
				  hl-page:: 197
				  ls-type:: annotation
				  id:: 634c1664-27cd-474d-b201-a1157b940e34
					- 这种效应：⼀一个事务中的写⼊改变另⼀一个事务的搜索查询的结果，被称为幻读
					- [[可重复读][[[RR]]]]隔离级别：可能出现幻读场景？ [wechat-doc.link](https://mp.weixin.qq.com/s/RQMyANKkOAKQ7w56JiPa4A)
						- ![image.png](../assets/image_1666754465506_0.png){:height 367, :width 853}
						- t:: 可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读
						- <span class="subw8">比如： 事务a启动快照读，没有任何记录；接着另外一个事务b插入了对应id的数据；接着a又继续执行一次当前读for update,就会看到b提交的那个记录;    第二种还是：a直接select id>100;接着b插入了记录200；a因为是snapshot读所以b可以插入，接着a又做了for update搞了当前读就读到了</span>
						-
		- 可序列化
		  ls-type:: annotation
		  hl-page:: 197
		  id:: 634c169d-338c-4cbc-84f4-42651f6f24b8
			- 在存储过程中封装事务
			  ls-type:: annotation
			  hl-page:: 198
			  id:: 634c1740-daaf-4bb3-b1fb-25517d7b7b13
				- 分区
				  ls-type:: annotation
				  hl-page:: 200
				  id:: 634c17bb-9ed3-4ece-a844-00c682fe1416
				- 串行执行小结
				  hl-page:: 200
				  ls-type:: annotation
				  id:: 634c180f-0cc7-4ace-864f-bbe272867217
	- [[两阶段锁]]定（2PL）
	  ls-type:: annotation
	  hl-page:: 200
	  id:: 634c1834-311f-4e71-a857-f9e679b9174e
		- 事务获得锁之后，必须继续持有锁直到事务结束（提交或中⽌止）。这就是“两阶段”这个名字的来源：第一阶段（当事务正在执⾏行行时）获取锁，第⼆阶段（在事务结束时）释放所有的锁
		  ls-type:: annotation
		  hl-page:: 201
		  id:: 6358a6cd-1f2f-4819-ba98-8a39ad2fc881
		- 2PL⽤用于MySQL（InnoDB）和SQL Server中的可序列列化隔离级别，以及DB2中的可重复读隔离级别
		  ls-type:: annotation
		  hl-page:: 201
		  id:: 6358a6a2-f3e2-4ef5-b5da-e432db8b6081
		- 谓词锁
		  ls-type:: annotation
		  hl-page:: 202
		  id:: 6358c284-6264-4fab-a428-88a2c098e2b9
			- 不不幸的是谓词锁性能不不佳：如果活跃事务持有很多锁，检查匹配的锁会⾮非常耗时
			  ls-type:: annotation
			  hl-page:: 202
			  id:: 6358c294-9fd3-4313-8200-cbe0aa1659e8
		- 索引范围锁
		  ls-type:: annotation
		  hl-page:: 202
		  id:: 6358c29c-03bc-4f43-a88d-db204077be1d
			- 大多数使⽤用2PL的数据库实际上实现了了索引范围锁（也称为间隙锁（next-key locking）），这是⼀一个简化的近似版谓词锁
			  ls-type:: annotation
			  hl-page:: 202
			  id:: 6358c2a8-05f0-4583-bed7-f383be02d68d
	- 序列列化[[快照]]隔离（SSI）
	  ls-type:: annotation
	  hl-page:: 203
	  id:: 6358c2e0-b0c1-4380-925f-a418865c4009
		- ⼀一个相当新的算法，避免了了先前⽅方法的⼤大部分缺点。它使⽤用乐观的⽅方法，允许事务执⾏行行⽽而⽆无需阻塞。当⼀一个事务想要提交时，它会进⾏行行检查，如果执⾏行行不不可序列列化，事务就会被中⽌止
		  ls-type:: annotation
		  hl-page:: 207
		  id:: 6358c452-103e-4c0a-9077-c43bc5ad3929
		- 悲观与乐观的并发控制
		  ls-type:: annotation
		  hl-page:: 203
		  id:: 6358c30d-abea-47e7-a6c5-2bd691274e88
	- 本章⼩小结
	  ls-type:: annotation
	  hl-page:: 206
	  id:: 6358c3ef-7fcd-4f43-8435-9bff9045f1e5
	-
- ### 第⼋章：分布式系统的麻烦
  hl-page:: 211
  ls-type:: annotation
  background-color:: #978626
  id:: 6358c47a-4679-4a9c-a6e6-680c1cd3447f
  heading:: true
	- 故障与部分失效
	  ls-type:: annotation
	  hl-page:: 212
	  id:: 6358c4b1-645b-4cf4-9dd2-54ad967d6e92
	- 云计算与超级计算机
	  ls-type:: annotation
	  hl-page:: 213
	  id:: 6358c4fa-55c2-4e4e-b40a-d79368432ac7
		- 如果要使分布式系统⼯工作，就必须接受部分故障的可能性，并在软件中建⽴立容错机制
		  ls-type:: annotation
		  hl-page:: 214
		  id:: 63634d94-82c6-490d-82b1-015b572d46f1
		- 从不可靠的组件构建可靠的系统
		  ls-type:: annotation
		  hl-page:: 214
		  id:: 63634db5-ecfa-47dc-a21c-8d2168d5ca7a
	- 不可靠的⽹网络
	  ls-type:: annotation
	  hl-page:: 215
	  id:: 63634de9-a347-4271-bb27-d12c60f8812a
		- 检测故障
		  ls-type:: annotation
		  hl-page:: 216
		  id:: 63634e73-5b91-487e-a004-b5cc13d245f8
		- ⽹络的不确定性使得很难判断⼀个节点是否⼯
		  hl-page:: 216
		  ls-type:: annotation
		  id:: 63634e85-187b-489d-a916-755407ec1d1b
	- 超时与⽆无穷的延迟
	  ls-type:: annotation
	  hl-page:: 217
	  id:: 63634ea4-5a99-4f08-985d-2fcfb16f9cac
		- 如果超时是检测故障的唯⼀一可靠⽅方法，那么超时应该等待多久？不不幸的是没有简单的答案。
		  ls-type:: annotation
		  hl-page:: 217
		  id:: 63634eae-bf37-497b-a45e-c7039883641e
	- ⽹络拥塞和排队
	  ls-type:: annotation
	  hl-page:: 217
	  id:: 63634ee8-d569-4f5d-bcab-1cf6cc763b3c
	- 同步⽹络 vs 异步⽹络
	  hl-page:: 219
	  ls-type:: annotation
	  id:: 63634f31-4bf1-44f8-bba3-84cee564529d
	- 我们不能简单地使⽹网络延迟可预测吗？
	  ls-type:: annotation
	  hl-page:: 219
	  id:: 636893ea-2d81-497c-84f7-0e220f770261
	- 不可靠的时钟
	  ls-type:: annotation
	  hl-page:: 220
	  id:: 63689459-6521-423d-84b8-6c7cd10e7bc9
		- 在分布式系统中，时间是⼀一件棘⼿手的事情，因为通信不不是即时的：消
		  ls-type:: annotation
		  hl-page:: 221
		  id:: 63689474-50b3-41cc-b838-641d314d26b3
		- 常⽤的机制是⽹络时间协议（NTP），它允许根据⼀一组服务器报告的时间来调整计算机时钟
		  hl-page:: 221
		  ls-type:: annotation
		  id:: 63689498-54b7-48da-a202-4db304778967
		- 时钟同步与准确性
		  ls-type:: annotation
		  hl-page:: 222
		  id:: 63689518-749a-4f7c-beca-53093a5ccb08
		- 依赖同步时钟
		  ls-type:: annotation
		  hl-page:: 222
		  id:: 6368959d-2961-41ee-a690-547e1ae595af
			- 有⼀一部分问题是，不不正确的时钟很容易易被视⽽而不不⻅见
			  ls-type:: annotation
			  hl-page:: 223
			  id:: 636895bd-8239-4329-98ed-0da1bd2aa1dc
		- 有序事件的时间戳
		  ls-type:: annotation
		  hl-page:: 223
		  id:: 636895c1-bf22-485b-95bf-467ea765937a
		- 这种冲突解决策略略被称为最后写⼊入为准（LWW）
		  ls-type:: annotation
		  hl-page:: 223
		  id:: 6368961a-d9ae-405f-9321-1b8ba40980ec
			- 数据库写⼊入可能会神秘地消失：具有滞后时钟的节点⽆无法⽤用快速时钟覆盖之前由节点写⼊入的值
			  ls-type:: annotation
			  hl-page:: 224
			  id:: 63689620-43bb-4413-bbe0-9cd96c2de4f3
			- LWW⽆无法区分⾼高频顺序写⼊入
			  ls-type:: annotation
			  hl-page:: 224
			  id:: 63689627-88dc-423f-9c5d-fa4c302d125a
			- 两个节点可以独⽴立⽣生成具有相同时间戳的写⼊入，特别是在时钟仅具有毫秒分辨率的情况下。
			  ls-type:: annotation
			  hl-page:: 224
			  id:: 6368962e-8aa6-4992-b922-b8539f29ab64
		- 时钟读数存在置信区间
		  ls-type:: annotation
		  hl-page:: 224
		  id:: 63689641-9473-4926-ad85-eaff7621e603
			- 不不确定性界限可以根据你的时间源来计算。如果您的GPS接收器器或原⼦子（铯）时钟直接连接到您的计算机上，预期的错误范围由制造商报告。如果从服务器器获得时间，则不不确定性取决于⾃自上次与服务器器同步以来的⽯石英钟漂移的期望值，加上NTP服务器器的不不确定性，再加上到服务器器的⽹网络往返时间（只是获取粗略略近似值，并假设服务器器是可信的）
			  ls-type:: annotation
			  hl-page:: 224
			  id:: 63689682-01bd-4bab-ae6b-00b7991334a5
		- 全局快照的同步时钟
		  ls-type:: annotation
		  hl-page:: 224
		  id:: 63689691-213c-475b-8dc2-88cf69952e17
			- 我们可以使⽤用同步时钟的时间戳作为事务ID吗？如果我们能够获得⾜足够好的同步性，那么这种⽅方法将具有很合适的属性：更更晚的事务会有更更⼤大的时间
			  ls-type:: annotation
			  hl-page:: 225
			  id:: 636896d1-debb-47c9-bd23-cef99216c2c2
			- Spanner以这种⽅方式实现跨数据中⼼心的快照隔离
			  ls-type:: annotation
			  hl-page:: 225
			  id:: 636896d7-c34c-42bc-bd0e-ec17097ee0f7
		- hl-page:: 225
		  ls-type:: annotation
		  id:: 636896f0-6885-4cf9-b422-784979f456df
		  暂停进程:: 考虑在分布式系统中使⽤用危险时钟的另⼀例
			- 如果程序执⾏行行中出现了了意外的停顿呢？例例如，想象⼀一下，线程在lease.isValid()⾏行行周围停⽌止15秒，然后才终⽌止。在这种情况下，在请求被处理理的时候，租约可能已经过期，⽽而另⼀一个节点已经接管了了领导者
			  hl-page:: 226
			  ls-type:: annotation
			  id:: 63689753-a030-44bf-9364-385e3b4b6ca3
			- 假设⼀一个线程可能会暂停很⻓长时间，这是疯了了吗？不不幸的是，这种情况发⽣生的原因有很多种：
			  ls-type:: annotation
			  hl-page:: 226
			  id:: 6368976c-d42b-4313-bd0c-6d8effff898d
				- 许多编程语⾔言运⾏行行时（如Java虚拟机）都有⼀一个垃圾收集器器（GC）
				  ls-type:: annotation
				  hl-page:: 226
				  id:: 63689774-2084-4f17-af97-38d04cf0195c
				- 在虚拟化环境中，可以挂起（suspend）虚拟机
				  ls-type:: annotation
				  hl-page:: 226
				  id:: 6368977b-5bcc-4ae9-ae69-f5f0c7b25da9
				- 如果应⽤用程序执⾏行行同步磁盘访问，则线程可能暂停，等待缓慢的磁盘I/O操作完成
				  ls-type:: annotation
				  hl-page:: 226
				  id:: 63689789-d3fa-4a83-8c26-e86e47826505
				- 发送SIGSTOP信号来暂停Unix进程
				  ls-type:: annotation
				  hl-page:: 227
				  id:: 63689797-6273-429e-8794-17d10ccd3a88
		- 响应时间保证
		  ls-type:: annotation
		  hl-page:: 227
		  id:: 636897c0-f5a9-4fc0-a3df-39351e642439
		- 限制垃圾收集的影响
		  ls-type:: annotation
		  hl-page:: 228
		  id:: 636e335d-4f7c-4743-8487-e86481f71fee
		- 知识、真相与谎⾔言
		  ls-type:: annotation
		  hl-page:: 228
		  id:: 636e339f-4c69-42b9-bc9b-0bc8bf724a9e
			- 在单台计算机上的程序的不不同之处：没有共享内存，只有通过可变延迟的不不可靠⽹网络传递的消息，系统可能遭受部分失效，不不可靠的时钟和处理理暂停
			  ls-type:: annotation
			  hl-page:: 228
			  id:: 636e33ba-21a6-4986-ab6f-cdd519175b39
			- 在分布式系统中，我们可以陈述关于⾏行行为（系统模型）的假设，并以满⾜足这些假设的⽅方式设计实际系统
			  ls-type:: annotation
			  hl-page:: 228
			  id:: 636e33e5-5dde-4a6d-a893-95de8d90bcb1
	- 真理理由多数所定义
	  ls-type:: annotation
	  hl-page:: 228
	  id:: 637a2de0-f92d-45b2-bba1-c1bb07178a9c
	- 这些故事的寓意是，节点不不⼀一定能相信⾃自⼰己对于情况的判断。分布式系统不不能完全依赖单个节点，因为节点可能随时失效，可能会使系统卡死，⽆无法恢复。
	  ls-type:: annotation
	  hl-page:: 229
	  id:: 637a2e47-c01f-44d2-ae15-bd1a220adae5
	- [[共识算法/consensus algorithms]]
	  hl-page:: 229
	  ls-type:: annotation
	  id:: 637a2e60-e352-4688-9d92-12d3eb30d0ef
	- 领导者与锁定
	  ls-type:: annotation
	  hl-page:: 229
	  id:: 638596b6-14f6-42df-a195-d7ab9f795ffa
	- 防护令牌
	  ls-type:: annotation
	  hl-page:: 230
	  id:: 638596dd-0561-47d8-b4a5-6740556e0712
		- 假设每次锁定服务器器授予锁或租约时，它还会返回⼀一个防护令牌（fencing token）
		  ls-type:: annotation
		  hl-page:: 230
		  id:: 638596f4-488a-4e0e-bdfb-60b0f05336aa
		- 将ZooKeeper⽤用作锁定服务，则可将事务标识zxid或节点版本cversion⽤用作屏蔽令牌
		  ls-type:: annotation
		  hl-page:: 230
		  id:: 63859737-639f-498b-874b-acadd84dd765
	- 拜占庭故障
	  ls-type:: annotation
	  hl-page:: 231
	  id:: 63859760-e134-4400-a8d3-25bc220b9053
		- 屏蔽令牌可以检测和阻⽌止⽆无意中发⽣生错误的节点（例例如，因为它尚未发现其租约已过期）。但是，如果节点有意破坏系统的保证，则可以通过使⽤用假屏蔽令牌发送消息来轻松完成此操作。
		  ls-type:: annotation
		  hl-page:: 231
		  id:: 63859775-3cc8-4496-949d-bacd0c63130c
		- 我们假设节点是不不可靠但诚实的
		  ls-type:: annotation
		  hl-page:: 231
		  id:: 63859786-b0ce-4040-a15f-9a8284b1531f
		- 如果存在节点可能“撒谎”（发送任意错误或损坏的响应）的⻛风险，则分布式系统的问题变得更更困难了了
		  ls-type:: annotation
		  hl-page:: 231
		  id:: 63859795-3c7a-4e31-9b77-22f35fede37d
		- 不信任的环境中达成共识的问题被称为[[拜占庭将军问题]]
		  hl-page:: 231
		  ls-type:: annotation
		  id:: 638597a3-f1dd-4d2c-83be-7c2db1e047d7
		- 当⼀一个系统在部分节点发⽣生故障、不不遵守协议、甚⾄至恶意攻击、扰乱⽹网络时仍然能继续正确⼯工作，称之为[[拜占庭容错(Byzantine fault-tolerant)]]
		  ls-type:: annotation
		  hl-page:: 231
		  id:: 6385981a-9c2e-4dc9-9a3b-abf473479efd
		- ⼤大多数服务器器端数据系统中，部署拜占庭容错解决⽅方案的成本使其变得不不切实际
		  ls-type:: annotation
		  hl-page:: 232
		  id:: 63859873-9695-4ef7-b017-e40105dda744
	- 弱谎⾔言形式
	  ls-type:: annotation
	  hl-page:: 232
	  id:: 638598a3-7f83-4c5d-8102-c4165f20baef
	- 系统模型与现实~~
	  ls-type:: annotation
	  hl-page:: 232
	  id:: 63859901-b7a3-4817-bc21-3239a744f7a9
		- 算法的编写⽅方式并不不过分依赖于运⾏行行的硬件和软件配置的细节。这⼜又要求我们以某种⽅方式将我们期望在系统中发⽣生的错误形式化
		  ls-type:: annotation
		  hl-page:: 232
		  id:: 6385992f-046f-4844-85f4-cf7133b413de
		- 关于定时假设，三种系统模型是常⽤用的
		  ls-type:: annotation
		  hl-page:: 232
		  id:: 63859933-4ab3-4706-b4a8-ad1b6d5f3f82
			- 同步模型
			  ls-type:: annotation
			  hl-page:: 232
			  id:: 63859937-54dc-44b9-92cd-dd3f14e83c38
				- 假设⽹网络延迟，进程暂停和和时钟误差都是有界限的。
				  ls-type:: annotation
				  hl-page:: 233
				  id:: 63859961-a34f-4844-8e4c-b9edc4eb52f9
			- 部分同步模型
			  ls-type:: annotation
			  hl-page:: 233
			  id:: 63859965-375a-4c7a-87de-c57ee47f6d8c
				- 意味着⼀一个系统在⼤大多数情况下像⼀一个同步系统⼀一样运⾏行行，但有时候会超出⽹网络延迟，进程暂停和时钟漂移的界限
				  ls-type:: annotation
				  hl-page:: 233
				  id:: 63859972-a60b-4fde-a0c5-085564e8409a
			- 异步模型
			  ls-type:: annotation
			  hl-page:: 233
			  id:: 6385997b-af0d-40d9-86ee-b4ea9e9c07a8
	- 我们还要考虑节点失效。三种最常⻅见的节点系统模型是
	  ls-type:: annotation
	  hl-page:: 233
	  id:: 6385999f-a6c5-4c1e-b016-41f9ce91e12b
		- 崩溃-停⽌止故障
		  ls-type:: annotation
		  hl-page:: 233
		  id:: 63ad1b74-5148-4dbb-859d-71bb27093663
		- 崩溃-恢复故障
		  ls-type:: annotation
		  hl-page:: 233
		  id:: 63ad1b85-3363-4374-b02d-f41f6874d456
		- 拜占庭（任意）故障
		  ls-type:: annotation
		  hl-page:: 233
		  id:: 63ad1b8d-18d6-4317-a171-33e91f811268
	- 安全性和活性
	  ls-type:: annotation
	  hl-page:: 234
	  id:: 63ad1bdc-99f1-4ea2-96b0-b2090baf85da
-
- ### 第九章. ⼀致性与共识
  hl-page:: 241
  ls-type:: annotation
  background-color:: #978626
  id:: 63ad1c2c-cf2c-4404-aebc-e056037cf72e
  heading:: true
	- [[脑裂]]（split brain）:: 多个节点都认为自己是leader，互相抢夺资源，导致系统混乱，数据异常
	  hl-page:: 243
	  ls-type:: annotation
	  id:: 63ad2279-8ef6-4eef-b899-081f570c483f
	- 线性⼀致性
	  ls-type:: annotation
	  hl-page:: 244
	  id:: 63ad22f4-f297-4ad3-81aa-0c2a5a666516
		- 本的想法是让⼀一个系统看起来好像只有⼀一个数据副本，⽽而且所有的操作都是原⼦子性的。有了了这个保证，即使实际中可能有多个副本，应⽤用也不不需要担⼼心它们
		  ls-type:: annotation
		  hl-page:: 244
		  id:: 63ad2322-73df-4b63-a928-1d84ef5e4332
	- 什么使得系统线性⼀一致？
	  ls-type:: annotation
	  hl-page:: 245
	  id:: 63ad235a-e470-403b-b88f-ee8170db4a85
		- 线性一致性与可序列化
		  hl-page:: 248
		  ls-type:: annotation
		  id:: 63ad241a-680d-4a12-9d80-28a5721bd126
		- 依赖线性⼀致性
		  ls-type:: annotation
		  hl-page:: 248
		  id:: 63ad245f-f3ab-46b3-8ac6-da143f31146e
			- 锁定和领导选举
			  ls-type:: annotation
			  hl-page:: 249
			  id:: 63ad247a-6e8c-4189-9751-c892260f6b57
				- 诸如Apache ZooKeeper 【15】和etcd 【16】之类的协调服务通常⽤用于实现分布式锁和领导者选举。它们使⽤用⼀一致性算法，以容错的⽅方式实现线性⼀一致的操
				  ls-type:: annotation
				  hl-page:: 249
				  id:: 63ad24af-fd65-436b-be7b-d1809e9ea031
			- 约束和唯⼀一性保证
			  ls-type:: annotation
			  hl-page:: 249
			  id:: 63ad24c1-c7b5-42b5-9199-a6d88e458263
			- 跨信道的时序依赖
			  ls-type:: annotation
			  hl-page:: 249
			  id:: 63ad24ed-00fe-4b1a-bf00-17459c750861
		- 实现线性⼀一致的系统
		  ls-type:: annotation
		  hl-page:: 250
		  id:: 63aecabc-61db-4939-8348-116479e60f7b
			- 单主复制（可能线性⼀一致）
			  ls-type:: annotation
			  hl-page:: 250
			  id:: 63aecaf0-e0d8-4f8a-83b4-91fa174bee66
			- 共识算法（线性⼀一致）
			  ls-type:: annotation
			  hl-page:: 250
			  id:: 63aecaf2-39ae-4080-b246-98b36bbc1ba0
			- 多主复制（⾮非线性⼀一致）
			  ls-type:: annotation
			  hl-page:: 251
			  id:: 63aecb00-ee2a-4221-928a-975841aca710
			- ⽆无主复制（也许不不是线性⼀一致的）
			  ls-type:: annotation
			  hl-page:: 251
			  id:: 63aecb03-2b7e-4e6e-91b2-ac6956abddbf
			- 线性⼀一致性和法定⼈人数
			  ls-type:: annotation
			  hl-page:: 251
			  id:: 63aecb0c-09af-43f1-a5d3-3c3d7224621c
		- 线性⼀一致性的代价
		  ls-type:: annotation
		  hl-page:: 252
		  id:: 63aecb13-3449-43f1-a990-53c16560ffb9
	- CAP定理理
	  ls-type:: annotation
	  hl-page:: 253
	  id:: 63aecc2f-95b7-4072-8cff-5407acd6e7e3
		- 不仅仅局限于多数据中⼼心部署，⽽而可能发⽣生在任何不不可靠的⽹网络上，即使在同⼀一个数据中⼼心内也是如此
		  ls-type:: annotation
		  hl-page:: 253
		  id:: 63aecc42-aee1-401a-bcca-8bed21386333
		- 因此不不需要线性⼀一致性的应⽤用对⽹网络问题有更更强的容错能⼒力
		  ls-type:: annotation
		  hl-page:: 253
		  id:: 63aecc61-4c3c-4fee-9f26-126bb7bf5176
		- CAP有时以这种⾯面⽬目出现：⼀一致性，可⽤用性和分区容忍：三者只能择其⼆二
		  ls-type:: annotation
		  hl-page:: 253
		  id:: 63aecc82-6f1b-4295-9622-bc26faf0f56e
	- 线性⼀一致性和⽹网络延迟
	  ls-type:: annotation
	  hl-page:: 253
	  id:: 63aeccb5-b6e7-46c2-b75b-e1311c180f75
		- 顺序保证
		  ls-type:: annotation
		  hl-page:: 254
		  id:: 63aecda1-839c-4d60-9bb5-7ef8239becdc
		- 顺序与因果
		  ls-type:: annotation
		  hl-page:: 254
		  id:: 63aecda8-7ffe-4768-8662-22fb1d655dd2
		- 序列列号顺序
		  ls-type:: annotation
		  hl-page:: 257
		  id:: 63aecdb9-133f-4cae-8efd-de0b066942d7
	- [[分布式事务与共识]]
	  ls-type:: annotation
	  hl-page:: 262
	  id:: 63aecdc8-8d09-4e7f-8637-7ae69592d139
		- 领导选举
		  ls-type:: annotation
		  hl-page:: 262
		  id:: 63aecdf7-4f23-4bbc-9e61-7065d9a37932
		- 原⼦子提交
		  ls-type:: annotation
		  hl-page:: 262
		  id:: 63aece01-f42c-4501-a574-d9735006f3e6
		- 原⼦子提交与二阶段提交（2PC）
		  ls-type:: annotation
		  hl-page:: 263
		  id:: 63aece15-bc63-40ea-8e46-3a49267a0d07
		- 从单节点到分布式原⼦子提交
		  ls-type:: annotation
		  hl-page:: 263
		  id:: 63aece2c-204e-4483-a540-587a89e6f6ba
		- [[两阶段提交2pc]]简介
		  hl-page:: 264
		  ls-type:: annotation
		  id:: 63aece68-5fa4-4d2b-99d0-facd37058adf
			- 两阶段提交（two-phase commit）是⼀一种⽤用于实现跨多个节点的原⼦子事务提交的算法，即确保所有节点提交或所有节点中⽌止。
			  ls-type:: annotation
			  hl-page:: 264
			  id:: 63aece77-3b0c-462f-b09c-cd5837d33494
			- 系统承诺
			  ls-type:: annotation
			  hl-page:: 265
			  id:: 63aecec2-06e5-42c9-af72-ee9b0f1d6073
				- 该协议包含两个关键的“不归路”点：当参与者投票“是”时，它承诺它稍后肯定能够提交（尽管协调者可能仍然选择放弃）。一旦协调者做出决定，这⼀决定是不不可撤销的。这些承诺保证了了2PC的原⼦子性。
				  hl-page:: 265
				  ls-type:: annotation
				  id:: 63aecf35-872b-40a4-8d34-8b930e434a3d
			- 为了了理解它的⼯作原理理，我们必须更详细地分解这个过程：
			  hl-page:: 265
			  ls-type:: annotation
			  id:: 63aecf3d-683e-4be2-83ba-501fd448392e
				- step:: 协调者发起，产生一个事务id。  协调者给参与者发起准备请求，参与者收到启动，任何一个失败协调者通知全部撤销；
			- 协调者失效
			  ls-type:: annotation
			  hl-page:: 265
			  id:: 63aecfbb-db38-43d0-baac-fa7dad541119
				- 协调者崩溃，会发⽣什么情况就不太清楚了
				  hl-page:: 265
				  ls-type:: annotation
				  id:: 63aecfcd-6af7-4931-a5a8-1fe54f8df2b4
		- [[三阶段提交]]
		  ls-type:: annotation
		  hl-page:: 266
		  id:: 63aed030-075f-4e7b-8963-dcb6b537c653
			- 两阶段提交被称为阻塞（blocking）原⼦子提交协议，因为存在2PC可能卡住并等待协调者恢复的情况。理理论上，可以使⼀一个原⼦子提交协议变为⾮非阻塞（nonblocking）的，以便便在节点失败时不不会卡住
			  ls-type:: annotation
			  hl-page:: 266
			  id:: 63aed046-13e3-4026-ba4f-b5e48e334419
			- 然⽽而，3PC假定⽹网络延迟有界，节点响应时间有限；
			  ls-type:: annotation
			  hl-page:: 266
			  id:: 63aed054-e00f-49b1-89fe-611d03ff224e
		- 实践中的分布式事务
		  ls-type:: annotation
		  hl-page:: 266
		  id:: 63aed06f-be92-4a18-a61c-8d16c11b1d50
			- 分布式事务的某些实现会带来严重的性能损失
			  ls-type:: annotation
			  hl-page:: 267
			  id:: 63aed088-36ef-438e-bcbf-88962461d925
	- 数据库内部的分布式事务
	  ls-type:: annotation
	  hl-page:: 267
	  id:: 63aed095-bab2-4202-a717-1089bc8f358d
		- 分布式事务的限制
		  ls-type:: annotation
		  hl-page:: 269
		  id:: 63aed0be-2e5b-4a15-b0b9-6c3b00a57765
			- 如果协调者没有复制，⽽而是只在单台机器器上运⾏行行，那么它是整个系统的失效单
			  ls-type:: annotation
			  hl-page:: 269
			  id:: 63aed62c-7f9a-4ad5-8ccd-de9c56c26231
	- 容错共识
	  ls-type:: annotation
	  hl-page:: 269
	  id:: 63aed64e-8109-4835-b308-aa3daa7f4c85
	- ⼀一致同意（Uniform agreement）
	  ls-type:: annotation
	  hl-page:: 269
	  id:: 63aed66c-1423-4c77-bf73-95ffe189c010
	- 完整性（Integrity）
	  ls-type:: annotation
	  hl-page:: 270
	  id:: 63aed66f-6f2b-4db3-8462-525c6e90f1a0
	- 有效性（Validity）
	  ls-type:: annotation
	  hl-page:: 270
	  id:: 63aed671-2f46-4daf-aed6-90eb9dca03d7
	- 单领导者复制和共识
	  ls-type:: annotation
	  hl-page:: 271
	  id:: 63aed67b-72b7-4e65-a382-9f93bee995aa
	- 服务发现
	  ls-type:: annotation
	  hl-page:: 274
	  id:: 63aed684-f9bd-4520-b689-dec238138959
	- 尽管服务发现并不不需要共识，但领导者选举却是如
	  ls-type:: annotation
	  hl-page:: 274
	  id:: 63aed6a3-a0ad-4854-be0c-28a6cce31904
	- 成员服务
	  ls-type:: annotation
	  hl-page:: 274
	  id:: 63aed6ab-40b9-4005-86c3-5b85f0c89e43
-
- ### 第三部分：衍⽣生数据
  hl-page:: 283
  ls-type:: annotation
  id:: 63aed6eb-dd32-42e6-9106-57ec7d3031cb
  background-color:: #497d46
- 记录和衍⽣生数据系统
  ls-type:: annotation
  hl-page:: 283
  id:: 63aed72a-fa41-4876-a073-6a6865e0e4f5
	- 存储和处理理数据的系统可以分为两⼤大类
	  ls-type:: annotation
	  hl-page:: 283
	  id:: 63aed730-49aa-4f7d-a581-0a8c3f87f943
		- 记录系统（System of record）
		  ls-type:: annotation
		  hl-page:: 283
		  id:: 63aed735-2ee1-4ce0-8707-541b4e3ae6e4
		- 衍⽣生数据系统（Derived data systems）
		  ls-type:: annotation
		  hl-page:: 283
		  id:: 63aed73e-a942-4bba-8711-64b24fe17cb5
- ls-type:: annotation
  hl-page:: 283
  id:: 63aed77b-f466-4db5-b5bc-2f36e3355e99
- ### 10. 批处理理
  ls-type:: annotation
  hl-page:: 285
  id:: 63aed78c-8a9d-4d8b-b609-64020b9e0642
  background-color:: #978626
	- 流式作业在事件发⽣生后不不久就会对事件进⾏行行操作，⽽而批处理理作业则需等待固定的⼀一组输⼊入
	  ls-type:: annotation
	  hl-page:: 287
	  id:: 63aed7d5-698a-4302-9a52-75dcae2f6b80
	- 批处理是构建可靠，可扩展和可维护应⽤用程序的重要组成部分
	  hl-page:: 287
	  ls-type:: annotation
	  id:: 63aed7e4-799a-4851-ac90-306962d1d885
- 使⽤用Unix⼯工具的批处理理
  ls-type:: annotation
  hl-page:: 288
  id:: 63aed805-3679-412f-97ae-f689b31a072a
- MapReduce和分布式⽂文件系统
  ls-type:: annotation
  hl-page:: 292
  id:: 63aed867-e533-444c-9990-5a6e18692640
- ls-type:: annotation
  hl-page:: 317
  id:: 63aed950-91ce-41d8-8071-eba49c28e441
  11. 流处理理
- 传递事件流
  ls-type:: annotation
  hl-page:: 319
  id:: 63aed96e-ccad-4647-b6a2-68b925625948
- ls-type:: annotation
  hl-page:: 350
  id:: 63aed9a6-3237-4a56-bfef-bf6bc7c76ba8
  12. 数据系统的未来
- 数据集成
  ls-type:: annotation
  hl-page:: 352
  id:: 63aed9c1-7684-44f3-a549-6a0f67f5abca
- 组合使⽤用衍⽣生数据的⼯工具
  ls-type:: annotation
  hl-page:: 352
  id:: 63aed9ea-fc1f-4d50-af64-8db820b5068a
- 理理解数据流
  ls-type:: annotation
  hl-page:: 353
  id:: 63aeda0b-67ce-4e2e-b2f5-57370ee47fcc
- 衍⽣生数据与分布式事务
  ls-type:: annotation
  hl-page:: 353
  id:: 63aeda43-4d67-4765-b96e-8309b33ae902
- 全局有序的限制
  ls-type:: annotation
  hl-page:: 353
  id:: 63aeda76-074a-44d4-bd4b-73b1ddc1f8e7
- 排序事件以捕捉因果关系
  ls-type:: annotation
  hl-page:: 354
  id:: 63aeda97-17cd-499c-8080-d2c81c862d71
- 批处理理与流处理理
  ls-type:: annotation
  hl-page:: 354
  id:: 63aedab6-0fc9-4019-9686-589110bd4640
-
