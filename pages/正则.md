title:: 正则
alias:: regex

- 正则问题
	- 1.非正则表达式报错： https://stackoverflow.com/questions/2704857/how-to-check-if-a-given-regex-is-valid
		- 编译会报错
	- 2.在用户写入正则表达式、及传递过程中，是不需要格外再加反斜杠`\`
		- java的提示的`\\` 两个反斜杠，并不是说在使用时要主动输入，比如Java的string输出后 `\\`  ---> `\`；  同理输入一个`\w+` java会自动编码为`\\w+`
		- ![image.png](../assets/image_1677658887682_0.png){:height 244, :width 525}
	- 3.结论，regex写法保持标准格式
	  >  在内存中编码方式各语言差异忽略，在文本中表现形式一定是一致的:
	  >  \\a  \\t \\n \\\\  \\\\\\\\       \\b   \\D
	- ```
	  sql REG "([A-Z])\w+   [a-z]\ \d"     ===》 Explore   r 1 
	  sql REG "([A-Z])\\w+   [a-z]\ \d"    ===》 E\www   r 1
	  				 \\只匹配'\' 
	                  w+ 配置 w...
	  ```
- [[正则和json之间的编码转义问题]]
	- 1. json里支持的转义和regex语法不一致，比如\w在json是无意义的= `\`  + `w`
	  2. http里body的`\w` --- > 到go的http后q输出raw string是 `\\\\w` ， 同理在mysql里一样的是`\\\\w`
	  3. `\"` 这个在go里的`"\""` 应该是`\\\\\\"`
	- 例子:  http request:
		- 转json后调用下游服务:
			- ```
			  http://xxxx/x_rule
			  {  ...
			          "rules" : "[\n   {\n      \"dbName\" : {\n         \"op\" : \"REG\",\n         \"value\" : [ \"testdb\\\\d\" ]\n      }\n   }\n]\n",
			  }
			  ```
		- x_rule接收转json:
			- ```
			  input打印log结果:  rules:"[\n   {\n      \"dbName\" : {\n         \"op\" : \"REG\",\n         \"value\" : [ \"testdb\\\\d\" ]\n      }\n   }  ===  还是保持4个\
			  
			  go的json序列化后: return (( dbName REG "testdb\d"));   符合预期
			  
			  update db的json时候，rule里的\\会自动成为: \\\\d一样ok   ----- 从db捞出，raw，msg还是4个\\\\，打印是\\
			  
			  
			  ```
		- 在 curl <<EOF EOF模式里需要`翻倍\`
			- ```shell
			  curl -XPOST -d @- '1000/x_rule'<<EOF
			  {            
			          "rules" : "[   {\"host\" : {\"op\" : \"REG\",\"value\" : [            \"a \\\\\\"  x \\\\\\\\w \\\\\\\\d \\\\\\\\a\\\\\\\\t\"         ]      }   }]" ,
			  }
			  EOF
			  ```
	- ```cpp
	  func main() {
	          xs := "for4\\\\w4adb"
	          fmt.Printf("%q, %s\n", xs, xs)
	          fmt.Printf("%q, %s", strings.ReplaceAll(xs, "\\", "\\\\"), strings.ReplaceAll(xs, "\\", "\\\\"))
	          fmt.Println()
	          var original = "{\"photo\":\"abc\\\\\\\\d\\\\w\"}"
	          fmt.Printf("original=q s:  %q, %s\n", original, original)
	          fmt.Println()
	          //var original = `{"photo":"abc\\w a\\w+ "}`
	  
	          fmt.Printf("%q\n", original)
	          fmt.Println("src msg: ", original)
	          un, err := strconv.Unquote(original)
	          fmt.Println(err, un)
	  
	          fmt.Println("unmarshal bytes")
	          msg := struct {
	                  Photo string
	          }{}
	  
	          err = json.Unmarshal([]byte(original), &msg)
	          if err != nil {
	                  fmt.Println("===> Unmarshal res: error ", err, msg.Photo)
	          }
	          fmt.Println("Unmarshal res: ", err, msg.Photo)
	  
	          msg.Photo = "abc\\wa\n"
	          x, err2 := json.Marshal(msg)
	          fmt.Println(x, err2)
	  
	  }
	  ```
-