- 1.[[进程线程]]区别、联系 #interview [#](https://www.zhihu.com/question/25532384) #card
  card-last-interval:: 8.32
  card-repeats:: 3
  card-ease-factor:: 2.08
  card-next-schedule:: 2024-05-05T23:06:56.734Z
  card-last-reviewed:: 2024-04-27T16:06:56.734Z
  card-last-score:: 3
	- 类似”**进程是资源分配的最小单位，线程是CPU调度的最小单位“**这样的回答感觉太抽象，都不太容易让人理解。 [[linux]] 
	  做个简单的比喻：进程=火车，线程=车厢
		- [[线程]]在进程下行进（单纯的车厢无法运行）
		- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
		- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
		- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
		- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
		- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
		- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
		- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
		- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”
	- **进程和线程都是一个时间段的描述，是CPU工作时间段的描述。是运行中的程序指令****的一种描述，这需要与程序中的代码区别开来。**
	- 线程之间共享内存，创建新线程的时候[[$blue]]==不需要创建真正的虚拟内存空间==，也不需要 MMU（内存管理单元）上下文切换 [#](https://zhuanlan.zhihu.com/p/300613281)
	-
	-
- 2.[[进程线程]]在cpu切换上的区别？ #interview #card
  card-last-interval:: 4
  card-repeats:: 2
  card-ease-factor:: 2.22
  card-next-schedule:: 2023-07-25T05:08:18.380Z
  card-last-reviewed:: 2023-07-21T05:08:18.380Z
  card-last-score:: 3
	- 进程切换过程先将context <span class="subw8 red">是指CPU寄存器和程序计数器在任何时间点的内容</span> 保存起来，以便恢复能知道原进程的下一个指令；另外一个进程上下文恢复到寄存器。
		- > 除了CPU以外所有的[执行环境](https://www.zhihu.com/search?q=%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A81152571%7D)，主要是寄存器的一些内容，就构成了的进程的上下文环境。进程的上下文是进程执行的环境。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去做的主要工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。[[上下文context]]
	- [[进程]][[上下文切]]换开销都有哪些  [进程上下文切换、残酷的性能杀手](https://www.cnblogs.com/emperor_zark/archive/2012/12/11/context_switch_1.html)
		- 那么上下文切换的时候，CPU的开销都具体有哪些呢？开销分成两种，一种是直接开销、一种是间接开销。
		  直接开销就是在切换时，cpu必须做的事情，包括：[#](https://zhuanlan.zhihu.com/p/79772089)
			- 1、切换[[页表]]全局目录
			- 2、切换内核态[[堆栈]]
			- 3、切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）
				- ip(instruction pointer)：指向当前执行指令的下一条指令
				- bp(base pointer): 用于存放执行中的[[$red]]==函数对应的栈帧的栈底地址==
				- sp(stack poinger): 用于存放执行中的[[$red]]==函数对应的栈帧的栈顶地址==
				- cr3:页目录基址寄存器，保存页目录表的物理地址
			- 4、刷下[[TLB]](页表缓存)
			- 5、系统调度器的执行代码
		- [#](https://zhuanlan.zhihu.com/p/79772089) 间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。
		   其实我们上面的实验并没有很好地测量到这种情况，所以实际的上下文切换开销可能比3.5us要大
	- [[线程]][[上下文切]]换耗时
		- 轻量级[[进程]]和普通进程的区别是可以共享同一[[内存地址空间]]、[[代码段]]、[[全局变量]]、同一打开文件集合而已。**从上下文切换的耗时上来看，Linux线程（轻量级进程）其实和进程差别不太大**。 ?
		- 这里a，b，c的执行是共享了A进程的上下文，CPU在执行的时候仅仅切换[[线程]]的上下文，而没有进行[[进程上下文]]切换的。进程的上下文切换的时间开销是远远大于线程上下文时间的开销。这样就让CPU的有效使用率得到提高。这**里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。线程主要共享的是进程的地址空间** [#](https://www.zhihu.com/question/25532384)
	- 2、引起[[上下文切换]]的原因
		- 当前任务的时间片用完之后，系统CPU正常调度下一个任务；
		- 当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；
		- 多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；
		- 用户代码挂起当前任务，让出CPU时间；
		- 硬件中断；
	- 3、前言，为了理解 [[上下文context]]切换，先看下virtual memory概念。vm和实际的mem之间是有一个映射关系的，那怎么快速映射呢？ 是放到buffer里，即TLB块里，页表中
		- 进程切换是不是要换这些信息
		- 线程呢？ 不用，因为是共享进程的上下文环境，比如代码段、数据段
		- 上下文切换主要开销,register失效，cpu告诉缓存失效、页表失效